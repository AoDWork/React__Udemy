//==============================================  БАЗОВЫЙ УРОВЕНЬ ==============================================\\

{/*    ====    02. Что такое реакт     ====

    React нужен для оптимизации (в основном для веб приложений - обычные программы в браузере) и ускорения разработки.
        Стандартизация инструментов на рабочем месте для разных разработчиков.

    
*/}


{/*    ====    03. Принципы реакта (SPA)     ====

    Реакт - библиотека на основе JS, разработана facebook для упрощения разработки юзер интерфейсов. С помощью реакта можно
        создавать одностраничные приложения - SPA(single page application), изменяют страницу без перезагрузки, происходит 
        контроль использования памяти приложения.



    Принципы(плюсы) реакт:

        - Декларативный(говорит какой результат нам нужен) - создаем юзер интерфйсы в разных состояниях, а  обновлением состояний
            занимается реакт.

        - Основан на компонентах(повторяющиеся блоки) - компактные и независимые от другого кода для переиспользования где угодно и
            легкого тестирования

        - Реакт может работать на сервере(Node.js) и на мобильныз платформах(React Native)


        - Использует препроцессор JSX (удобное представление разметки в JS коде, писать js код можно прямо в ней)

        - Алгоритм сравнения(реконселейшн) - отслеживает какие части изменились и обновляет только их.

        - Virtual DOM
    
*/}


{/*    ====    04. Create React App (CRA)     ====

    CRA - настроенная сборка которая создается по вводу 1 строки кода в консоли среды разработки  -  npx create-react-app my-app
        
    cd my-app - зайти в папку с проектом

    npm start - запустить проект ( в режиме разработки)



    В nodemodules - все модули нужные для работы сборки. Основные - webpack - собирает проект, поддерживает хот релоад сервера, и
        Babel - компилирует JSX разметку, следит за поддержкой браузеров.

    Если включен плагин JShint нужно его отключить потому что он будет конфликтовать с подключенным по умолчанию в проекте
        ES lint и также он не понимает JSX будет подсвечивать ошибки.


    После запуска приложения в консоли браузера видим сообщение которое предлагает установить расширения для удобного дебаггинга,
        устанавливаем

    
*/}


{/*    ====    05. JSX, его ограничения     ====

    index.js - основной файл в котором ренедериться компонент с нашим приложением App.js. Если писать код в index то бывает
        что не происходит автоматическое обновление.

        //! Код в index может отличаться в зависимости от различных версий React 

    

    Первое что видим в файле это импорты. Если не указан путь то импортируется из папки node_modules. 

        Сначала импортируется React из модуля react - отвечает за работу реакта с JSX и внутренними возможностями.

        ReactDOM - позволяет работать с DOM структутрой на странице(вставлять реакт и приложение на страницу)

        import App from "./App" - компонент с приложением

        web Vitals - измеряет производительность приложения, можно удалить


    //! Март 22 вышел реакт 18. Теперь немного изменился index. ReactDOM теперь импортируется из 'react-dom/client' это спец. раздел
        который относится к клиентской части реакта, также изменился порядок команд, но принцип остался тот же. Если в index не 
        изменить код то просто не будут работать новые фишки 18 реакта и он будет работать как на предыдущей версии.

        Документация на английском актуальна для последнего обновления, рус версия может не успевать за ней.

        В курсе показан синтаксис 17 реакта.


        У ReactDOM вызывается метод render и передаются 2 аргумента, 1й - что - приложение которое рендериться, 2й - куда.
        //! Этот render должен вызываться только раз на самом верхнем уровне приложения( index ), бывают исключения. 
        Все остальное приложение собираем по отдельным файлам и заключаем в такую ф-ю как - App, его мы и будем предоставлять
        странице чтобы она нам его показала.



    //! В реакте до 17й версии для работы Babel нужно было импортировать React в каждый файл где есть jsx, после 17й версии 
        переписали код и теперь этого делать не нужно, импортируем только в index.js. При работе со старыми проектами если
        удалить импорты без апгрейда до новой версии реакта сломается проект.



    Реакт елемент - елемент интерфейса
        
            const elem = <h2>Hello</h2> 

        //! Если елемент большой(многострочный) нужно его оборачивать в скобки и у него всегда должен быть 1 родитель(обертка div)
        это связанно со способом создания элемента (создается один простой елемент а остальные елементы помещаются внутрь него как
        текст)  

            const elem = (
                <div>
                    <h2>Hello</h2>
                    <input type="text" />
                    <button />
                </div>
            ) 



    //! Чтобы в jsx работал emmet для создания тегов через таб нужно его донастроить(по умолчанию он не знает что в js файле можно
        вставлять верстку). Открываем настройки юзера - ctrl+, - сверху написано user, выбираем extensions -> emmet -> 
        include language -> add item  -> key - javascript, value - javascriptreact



    //! Главные правила елементов:
        - использовать скобки для многостроных элементов
        - один родитель для многострочного элемента
        - не забывать закрывать тег



    JSX позволяет вставлять внутрь себя код как при использования строки с обратными кавычками(бектиками) но без доллара

            <h2>Text: {text}</h2>

            return  <button>{ logged ? "Enter" : text }</button> - использование логического условия(//! тернарный оператор, if 
                                                                   не работает внутри таких фигурных в елементах)

        //! можно вставлять текст, мат операции,  свойства объектов, вызов ф-й/методов, КРОМЕ ОБЪЕКТОВ, тоесть нельзя поместить
        //! <h2>{new Date()}</h2> - будет ошибка, так сделано для безопасности кода, чтобы нельзя было помещать сторонние скрипты.
        //! В реакте все значения экранируются и переводяться встроки и когда запустится команда которая вернет объект то при 
        //! переводе будет просто 'object object'. С массивом будет работать но все елементы сконкатенируются.
        //! Правило именно для показа на на странице, передавать в props объекты можно, но перед показом на странице нужно из
        //! объекта вытащить содержимое.

          
        
    Аттрибуты css можно использовать с особенностями:
    
        - всегда пишуться в камел кейс если состоит более чем из 1 слова (исключения aria- , data-  -> aria-label)

                background-color  -> backgroundColor

                tabindex -> tabIndex

                <button tabIndex="0" >Click</button>


        - некоторые аттрибуты пишуться по своему в реакте потому что эти слова зарезервированы в JS

                class   ->  className

                for     ->  htmlFor

    
*/}


{/*    ====    06. Элементы и компоненты     ====

    Одна из основных концепций реакта - разбиение приложения на компоненты - функции которые могут возвращать JSX элементы,
        блоки юзер интерфейса которые могут иметь собственное поведение. Они могут переиспользоваться в разных местах кода и 
        состоят из элементов. 
        
        //! элементы в реакте неизменяемые, нельзя просто обратится к нему через класслист и добавить или
        удалить класс, назначить аттрибут. //! Чтобы изменить элемент нужно его полностью перерисовать на странице. В коде проводим
        операции что то изменяем, потом элемент проходит через виртуал дом и потом отрисовывается на странице взамен старого но уже
        с новыми параметрами. Можно в частных случаях напрямую обратиться к ДОМ элементу, но это используется очень редко.



    КОМПОНЕНТЫ правила:
        - всегда пишутся с большой буквы  <App/>
        - всегда есть return - чтоб возвращать JSX
        - если компонент слишком большой или его часть может использоваться в другой части кода, обладает логикой, нужно 
            выделить в отдельный компонент


        Чтобы использовать компонент в другом файле его нужно експортировать или по дефолту - тогда в другом файле можно при
        импорте назвать его по другому или именновано, тогда при импорте нужно указать именно то имя с которым файл експортировался.

        файл App
            export {Header};        или  добавляем перед самим елементом(ф-й) export function Btn() {...
            export default App;

        Файл индекс
            import { Header } from './App';
            import App from './App';        или  import MyApp from './App';



    Можно создавать через скобки как внутренности елементов, так и свойства тегов. //! В style вставлен созданный объект.
            const Field = () => {
                const holder = "Enter here"
                const styledField = {
                    width: '300px'
                }
                return <input placeholder={holder} type="text" style={styledField}/>
            }
        


    Классы в JS это теже ф-ии просто обернути в оболочку. Тоесть ф-и могут быть классами

            const Field = () => {
                const holder = "Enter here"
                const styledField = {
                    width: '300px'
                }
                return <input 
                        placeholder={holder} 
                        type="text" 
                        style={styledField}/>
            }

        перепишем как класс - для того чтобы они работали как задумано в реакте, нужно чтобы создаваемый класс унаследовал 
        поведение от родительского класса реакта. Для этого в файл импортируем реакт а потом из него достанем компонент с классом,
        если не нужно ничего конструировать то constructor не прописываем, но вклассовом компоненте должен быть как минимум 1 метод
        который будет что-то создавать (возвращать JSX) - render()
            
            import React from react;  -> const Field extends React.Component {

                или можно сразу вытащить компонент и не прописывать реакт каждый раз при создании классового компонента

            import {Component} from react;  -> const Field extends Component {

            const Field extends React.Component {
                render() {
                    const holder = "Enter here"
                    const styledField = {
                    width: '300px'
                    }
                    return <input 
                            placeholder={holder} 
                            type="text" 
                            style={styledField}/>
                }
            }
    

*/}


{/*    ====    07. Строгий режим     ====

    По функционалу он похож на strict mode в JS. Можно вытаскивать объекты реакта через запятую

            import React, {StrictMode, Component} from 'react';

            <StrictMode>
                <App />
            </StrictMode>


        Простым языком это компонент для обнаружения потенциальных проблем в приложении. Он ничего не рендерит и не заменяется 
        никаким другим компонентом, а существует внутри реакта - он активирует дополнительные проверки и предупреждения для потомков
        (вложенных в него компонентов), тоесть этот компонент можно использовать где угодно в приложении. Он помогает обнаруживать
        устаревшие и небезопасные конструкции и сообщает о некторых побочных эффектах. Эта возможность будет работать только в 
        режиме разработки.

        Это полезно в случаях: 
            - копирования чужого(устаревшего) кода 
            - когда нужно перевести приложение со старой версии реакта на новую, тогда можно быстро обнаружить те участки кода
                которые следует исправить перед переходом.

        Сообщения будут показываться в консоли браузера и в терминале.

    
*/}


{/*    ====    09. Создание нового проекта (практика)     ====

    Приложение учета сотрудников. Можно будет добавлять/удалять сотрудников, отмечать их, делать фильтраци(по размеру ЗП, 
        На повышение(чекбокс), имени - инпут). Это приложение показывает основные момента при работе с веб технологией 
        CRUD - Create Read Update Delete. Приложение - разновидность TODO - приложений которые часто дают на собеседованиях
        чтобы увидеть человек работает с этими базовыми концепциями. Заморачиваться стилями для приложения не будем - воспользуемся
        готовым набором классов которые будем подключать через CDN сервер (cdnjs.com).

        В этом уроке будем создавать структурную оболочку приложения - версткой разбитой на правильные компоненты и использующей
        правильные елементы по всем правилам из предыдущих уроков. Можно скачать по ссылке проект с готовой версткой и установить
        необходимые модули через npm i.
 


    Подключим бутстрап для задания готовых стилей через cdnjs.com - заходим на сайт, вбиваем bootstrap заходим в него и копируем
        в index ссылку на ксс стили, //! может понадобиться обновить ссылку потому что в видео другие версии, их можно выбирать на 
        сайте 

        в видео версия 5.1.1
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.2/css/bootstrap.min.css">
        
        для иконок делаем такуюже манипуляцию, в видео версия 5.15.4
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">



    Рассмотрим приложение, визуально делиться на 4 блока
        - хедер с информацией
        - блок фильтрации: поиск по имени + фильтры
        - список сотрудников
        - блок добавления нового сотрудника инпуты - имя + зарплата и кнопка добавить



    Начнем создавать такую структуру в проекте, в папку components будем складывать все остальные папки, использоваться для 
        именования будет кебаб стиль(через дефис)  employees-list-item , в каждой папке будет js(jsx - разницы нету) + css файл
        
            components
                app
                app-filter
                app-info
                employees-add-form
                employees-list
                employees-list-item
                search-panel

        
        Применение бутстрап стиля в компоненте - просто пишем название form-control и search-input - которые есть в бутстрапе и для 
        них соотносятся определенные стили

            const SearchPanel = () => {
                return (
                    <input type="text"
                            className="form-control search-input"


        
        Значение по умолчанию в реакте если не будет передано значение defaultValue

            <input type="text" className="list-group-item-input" defaultValue="1000$"/>


*/}


{/*    ====    10. Свойства компонентов - props    ====

    Свойства компонента(props) - предназначены для того чтобы заполнять контент компонента различным содержимым. Например если 
        имеется 10 карточек товара, то они будут однотипными по структуре и отличаются только содержимым, поэтому можно создать
        1 компонент - карточку и в props закидывать различное содержимое чтобы каждая карточка отображала свое.
        
            function WhoAmI (props) {
                return(
                    <div>
                    <h1>My name is {props.name}, surname - {props.surname}</h1>
                    <a href={props.link}>My profile</a>
                    </div>
                )
            }


            function App() {
                return (
                    <div className="App">
                    <WhoAmI name="John" surmane="Smith" link="facebook.com"/>
                    <WhoAmI name="Alex" surmane="Shepard" link="google.com"/>
                    </div>
                );
            }


        Можно сразу деструктуризировать - вытащив нужные свойства и тогда убрать слово props

             function WhoAmI ({name, surname, link}) {
               return(
                    <div>
                    <h1>My name is {name}, surname - {surname}</h1>


        //! В props можно передавать всё даже объекты и тогда прочитать нужно будет по name.firstName, потому что если оставить
        //! просто name то это будет объект и он не отобразиться напрямую на странице

            <WhoAmI name={{firstName: "John"}} surmane="Smith" link="facebook.com"/>

            function WhoAmI ({name, surname, link}) {
               return(
                    <div>
                    <h1>My name is {name.firstName}, surname - {surname}</h1>


        Функции - тогда в компоненте нужно будет вызвать эту ф-ю
                
            <WhoAmI name={ () => {return "John"} } surmane="Smith" link="facebook.com"/>

            function WhoAmI ({name, surname, link}) {
               return(
                    <div>
                    <h1>My name is { name() }, surname - {surname}</h1>



        //! Главное правило реакта что props внутри компонента не должны изменяться(иммутабельность).

    
*/}


{/*    ====    11. Практика свойств на проекте     ====

    Сделаем кастомизацию сотрудников( пока что 3 Джона Смита с одинаковой ЗП). Передадим props в компонент EmployeesListItem и 

            <EmployeesListItem name="John C." salary={800} />

        модифицируем его для работы с ними

            const EmployeesListItem = ({name, salary}) => {
                return (
                    <li className="list-group-item d-flex justify-content-between">
                        <span className="list-group-item-label">{name}</span>
                        <input type="text" className="list-group-item-input" defaultValue={salary + "$"}/>



    Теперь карточки сотрудников отличаются, но данные захардкожены(жестко зафиксированы) и если будет 1000 сотрудников нужно будет 
        вносить все данные руками. Чтобы такого не делать поработаем с данными, допустим с сервера они пришли в компонент App и 
        сохранились, создадим их там в формате массива который содержит объекты в которых есть свойства name и salary. И передадим
        их как свойства в нужный компонент EmployeesList. 

            function App() {
                const data = [
                    {name: "John C.", salary: 800},
                    {name: "Alex M.", salary: 300},
                    {name: "Carl W.", salary: 5000}
                ]

                <EmployeesList data={data}/>


        Теперь можем использовать данные которые пришли в props, но снова нужно будет вбивать все вручную например так
                
                <EmployeesListItem name={data[0].name} salary={data[0].salary} />

            и чтобы так не делать используем метод перебора массива map который при переборе возвращает НОВЫЙ массив объекто в 
            каждый объект поместив элемент JSX c свойствами из аналогичного(по порядку) объекта предыдущего массива, а значит 
            придерживается правила иммутабельности не изменять входящие данные, получим новый массив с элементами jsx и потом его
            выведем на страницу.

                const EmployeesList = ({data}) => {
                    
                    const elements = data.map( item => {
                        return <EmployeesListItem name={item.name} salary={item.salary} />
                    })

                    return (
                        <ul className="app-list list-group">
                            {elements}
                        </ul>
                    )
                }
                            
            Теперь список сотрудников формируется динамически.

            //! Можно улучшить запись добавлением спред оператора, тоесть при name={item.name} - мы вытаскиваем значение name из 
            объекта item и дальше также вытаскиваем salary, по сути мы присваиваем name = name и так как названия не меняются
            можно просто сделать спред оператор который сам распакует нам названия со значением что превратит объект
            {name: "John C.", salary: 800} в строку  - name: "John C.", salary: 800

                return <EmployeesListItem { ...item } />

    
*/}


{/*    ====    12. Работа со списками и алгоритм согласования     ====

    В консоли вылезла ошибка что каждый елемент списка должен иметь уникальное свойство ключ - "key".

    Процесс создания дом дерева затратный по ресурсам, на помощь ему приходит виртуал ДОМ. Но его построение тоже не очень
        дешево если используется много элементов, например список из 200 строк и одна в середине удалилась как в таком случае
        отработает приложение, тут и сработает механизм согласования(сверки, реконцеляции).  Или вместо корневого для
        списка тега li он измениться на div то реакт не изменяет узел а уничтожает его и создает заново вместе со списком из
        200 объектов, но если поменяется только стили у тега, то внутренности не будут уничтожены, а пресоздасться только корневой
        тег с новыми стилями и рекурсивно реакт пойдет смотреть есть ли отличия старого дерева объектов от новго который реакт
        создаст при выявлении отличий реакт перерисует в реальном ДОМ дереве только те елементы которые изменились.

        На базовом уровне сравнение списка идет по порядку, начиная с первого. Если елемент добавляется в конец то реакт пройдет
        по всему списку увидит что елементы одинаковые, найдет последний новый елемент и дорисует его. Но если мы помещаем новый
        елемент в начало списка, то он теперь будет первым и не будет равен предидущему первому, а предыдущий первый станет вторым
        и не будет равен старому второму, таким образом прийдется перерисовывать все елементы. Чтобы реакт быстрее сравнивал(имел
        какую то привязку, видел что элемент тот же и в нем ничего не изменилось) используют key и именно по нему реакт будет
        определять изменился елемент или нет. //! Ключи должны быть уникальными только среди своего списка. Если с сервера не пришел
        //! id (не написали) то допускается использование индекса элемента как ключа но такое допускается только если не будет
        //! меняться порядок элементов. Плохая практика использование для ключей ф-й по типу Math.random



    Захардкодим уникальные id в data
        
            const data = [
                {name: "John C.", salary: 800, increase: true, id: 1},
                {name: "Alex M.", salary: 300, increase: true, id: 2},
                {name: "Carl W.", salary: 5000, increase: false, id: 3}
            ]

        и в методе map будем использовать их как ключи, так как названия у нас не совпадают тоесть у нас будет key = id то нужно
        вытащить их отдельно для этого сделаем частичную деструктуризацию вытащив id, а остальные свойства сохраним в itemProps
        который деструктуризируем как раньше item

            const elements = data.map( item => {
                const {id, ...itemProps} = item
                return <EmployeesListItem key={id} { ...itemProps } />
            })
  
    
*/}


{/*    ====    13. Состояния компонентов     ====

    Состояние компонента(state) может динамически изменяться в отличие от свойств(например цифра в компоненте счетчике или номер 
        активного слайда в слайдере). Изначально состояние можно было создать только в классовом компоненте, потом с введение хуков
        такая возможность появилась и в функциональном. Поэтому рассмотрим state на примере классового компонента, чтобы понимать
        как оно работает.



    Продолжим в App переделав ф-й компонент WhoAmI в классовый. 

            function WhoAmI ({name, surname, link}) {
                return(
                    <div>
                    <h1>My name is {name}, surname - {surname}</h1>
                    <a href={link}>My profile</a>
                    </div>
                )
            }


        Для этого импортируем компонент из реакта. //! Когда класс вызывается он создает свой экземпляр и чтобы в него передались
        props нужно использовать конструктор, в нем принять эти props и чтобы их использовать пропишем слово супер и в него 
        передадим props. Эта возможность работы с prop приходит из Component от которого и наследуется наш классовый компонент.
        Теперь внутри каждого экземпляра класса будет свойство this.props - с объектом props(то что мы туда передали). Чтобы 
        каждый раз не писать this сделаем деструктуризацию в render и вытащим свойства из него.

            import { Component } from react;

            class WhoAmI extends Component {
                constructor(props) {
                    super(props)
                }
                render() {
                    const {name, surname, link} = this.props
                    return(
                    <div>
                        <h1>My name is {name}, surname - {surname}</h1>
                        <a href={link}>My profile</a>
                    </div >
                    )
                }
            }

        //! В консоле предупреждение о бесполезном конструкторе, так как мы тудеа ничего своего не добавили то его можно просто
        удалить. Но пока оставим его что бы знать что он нужен если мы захотим добавить в компонент свое поведение(ф-и или state).



    Так как props менять мы не должны то для того чтобы ввести динамику создадим свойство state в конструкторе - это такой объект
        в котором храняться различные свойства которые будут динамически изменяться. //! В нем можно делать много свойств и дописывать
        вложенные структуры. Используем значение years в компоненте обратившись как к обычному свойству в объекте this.state.years

            constructor(props) {
                super(props)
                this.state = {
                    years: 27
                }
            }


            <h1>My name is {name}, surname - {surname}, age - {this.state.years}</h1>



    Добавим кнопку с событием в компонент для смены значения свойства years. Передаем в onClick только название ф-и без вызова, 
        вызываться будет когда юзер будет кликать по кнопке. Теперь создадим этот метод через стрелочную ф-ю, //! через обычную
        ф-ю будет ошибка ???  - рассмотрим в следующих уроках. Видим что кнопка появилась для каждого компонента своя.

            nextYear = () => {
            }

            <button onClick={this.nextYear}>+++</button>



    Напрямую изменить(мутировать) state нельзя, тоесть нельзя написать this.state.years++ - не будет происходить изменение, для 
        этого нужно использовать комманду(ф-ю)  this.setState() - в себя она принимает аргумент - объект с новым состоянием(объектом)
        который прямо тут и конструируем - записываем свойство years в котором будет текущее состояние this.state.years - увеличиное
        на один, инкримент ++ - помещаем в префиксной форме - перед значением.

            nextYear = () => {
                this.setState({
                years: ++this.state.years
                })
            }


        теперь при нажатии на кнопку изменяется текст age компонента, причем для каждого компонента цифра храниться своя.
        //! Но видим что предупреждение о мутации в консоли не пропало, потому что мы снова меняем напрямую предыдущий state
        //! оператором ++, поэтому для увеличения или уменьшения используется такая запись  years: this.state.years + 1

            nextYear = () => {
                this.setState({
                years: this.state.years + 1
                })
            }



    //! Когда запускается setState - она производит перерисовку(запускает метод render) всего компонента с новым состоянием. 
    //! setState выполняется асинхронно и state в 95% случаев зависит от предыдущего state, тоесть когда увличивается с 30 до 31
    //! счетчик то мы знаем что перед 31 предыдущее состояние должно быть только 30 чтобы получить правильный результат. А из-за
    //! асинхронности может получиться так что предыдушее состояние еще не обновилось, а мы уже снова обновляем. Тоесть если 
    //! сейчас очень быстро клацать кнопку то может случиться так что счетчик собЪется и результат будет не таким как нам нужен.
    
    //! Так получается потому что несколько изменений состояний объединяются в одно и приоритет выполнения может быть отдан 
    //! другому работающему процессу и будет ждать его завершения, такая у реакта оптимизация работы.

    //! Чтобы от этого избавиться можно внутрь setState передать другую ф-ю тоесть коллбек, таким образом реакт будет ждать 
    //! выполнения предыдущего коллбека перед выполнением следующего. При этом ф-я принимает текущее состояние state и вместо записи 
    //! return мы берем в круглые скобки весь объект который она возвращает, и так как у нас state уже приходит без this, нам больше 
    //! не нужно его вытягивать из объекта и можно this удалить.

            nextYear = () => {
                this.setState(state => ({
                    years: state.years + 1
                }))
            }

        //! Если state не зависит от предыдущего, например вводиться в инпут новое значение которое не зависит от старого значения
        то можно передавать просто объект.



    //! В state может быть больше чем 1 свойство, возникает вопрос что будет с другими свойствами раз мы в setState указали только
    //! одно. setState меняет в state только то что мы указали, а остальное остается неизменным и не стирается.

    
*/}


{/*    ====    14. Самостоятельное задание на работу с состоянием     ====

    Домашнее задание по ссылке https://codepen.io/ihinstone/pen/QWvYePv

    
*/}


{/*    ====    15. События в реакт, вспоминаем this     ====

    onClick мы уже использовали, рассмотрим остальные с базовых понятий, продолжаем на проекте из 13 урока.

    Для назначения обработчика события в реакте прописываем событие в качестве аргумента в формате camelCase. Создадим форму с
        инпутом и создадим у него обработчик событий onInput. //! В JS onInput срабатывает когда впечатывается что то в инпут, а
        //! onChange - когда уводится фокус от элемента. В реакте они работают одинаково и зачастую используют onChange.
        Создадим и положим в него метод commitInputChanges, хотим чтобы при впечатывании текста он попадал в state. Для этого
        в state создадим свойство position(должность). Также вынесем в отдельные переменные position и years чтобы не писать
        часто this.state. //! addEventListener вызывать нигде не нужно реакт все делает сам когда компоненту или елементу
        //! назначаем событие. Для отмены стандартного поведения браузера в реакт работает только  event.preventDefault(); другие
        //! методы такие как return false в реакте работать не будут


             commitInputChanges = (e) => {
                this.setState({
                    position: e.target.value
                })
            }

            render() {
                const { name, surname, link } = this.props
                const {position, years} = this.state
                return (
                <div>
                    <button onClick={this.nextYear}>{this.state.text}</button>
                    <h1>My name is {name}, surname - {surname}, 
                        age - {years}, 
                        position - {position}</h1>
                    <a href={link}>My profile</a>
                    <form>
                    <span>Введите должность</span>
                    <input type="text" onChange={this.commitInputChanges} />
                    </form>
                </div >
                )
            }
            }

        

    //! Для методов всегда нужно использовать СТРЕЛОЧНЫЕ ф-и. Потому что this свой для каждого екземпляра класса(объекта созданного из
    //! этого класса). Когда работает с props и state тут всегда будет ссылка на данный екземпляр. А с обработчиками события сложнее
    //! когда событие срабатывает - контекст теряется, из-за того что ф-я события вызывается внутри другой ф-и - render при этом
    //! this становиться undefined и если просто сделать из стрелочной ф-и обычную то будет ошибка - не могу прочитать свойство у
    //! undefined когда выполняется setState, на этом этапе он и теряется. Ф-я setState вызывается внутри ф-и nextYear а она 
    //! вызывается внутри render.

             nextYear () {
                this.setState(state => ({
                    years: state.years + 1
                }))
            }


    //! Разберем все 3 варианта как избежать данной проблемы:

        //! 1) через bind. Прописываем в конструкторе эту строку  this.nextYear = this.nextYear.bind(this)
        //! Слева будет обычное свойство которое будет у екземпляра класса который был создан.
        //! С права обращаемся к методу this.nextYear - которые есть в классе и мы его байндим(привязываем)
        //! к конкретному екземпляру класса .bind(this). Если по простому то мы жестко привязываем метод из родительского класса к 
        //! созданному екземпляру. Так будет работать с конструкцией выше. 


            constructor(props) {
                super(props)
                this.state = {
                    years: 27,
                    text: '+++',
                    position: ''
                }
                this.nextYear = this.nextYear.bind(this)
            }

            //! неудобство в том что каждый метод который у нас используется в обработчиках событий нужно будет байндить.


        //! 2) записывать методы через стрелочную ф-ю (использовать синтаксис полей классов).


        //! 3) вызвать событие через анонимную стрелочную ф-ю(коллбек) в самом обработчике. Вызывается анонимная ф-я при клике, она 
        //! внутри себя вызовет  this.nextYear() и за счет того что эта коллбек ф-я стрелочная - this она берет у своего родителя 
        //! в нее попадет ссылка на наш екземпляр класса(объекта)

            <button onClick={ () => this.nextYear() }>{this.state.text}</button>

            //! неудобство что при каждом пересоздании компонента будет создаваться снова эта коллбек ф-я и проблема может быть
            //! если этот колбек дальше передается по props. При изменении props будет заново создаваться тот компонент в который
            //! этот коллбек передается потому что новый коллбек будет отличным от предыдущего, немного теряется оптимизация.

            //! Преимещество - можно передать аргумент в ф-ю. При этом нужно вреяную добавить событие в анонимную ф-ю, а в вызов
            //! ф-и можно добавить аргумент и принять его в методе.

            commitInputChanges = (e, color) => {
                console.log(color)
                this.setState({
                position: e.target.value
                })
            }

            <input type="text" onChange={ (e) => this.commitInputChanges(e, 'some color')} />

   
*/}


{/*    ====    16. Практика состояний на проекте     ====

    Открываем проект. Реализуем при клике на печеньку изменение состояния(state) в этом компоненте. Для этого переделаем компонент
        в классовый и создадим в нем state. Испортируем компонент из реакта, прописываем класс + екстенд компонент, создаем
        конструктор, в нем создаем state со свойством increase, всё что было до этого в компоненте помещаем в метод render
        и добавляем деструктуризацию переменных из this.props чтобы легче обращаться было. Добавим обработчик события и ф-ю
        для него.

        Так как будем изменять состояние в зависимости от того которое было раньше(тоггл) через ! - не(оно инвертирует предыдущее
        на противоположное, так как значение булево и их всего 2, получиться автоматический тогглер), то нужно записать коллбек
        и в нем используем деструктуризацию чтобы сразу вытащить свойство increase из state.

        Теперь значение increase будем брать не из props а из state, поэтому изменим деструктуризацию.

            import { Component } from 'react'
            import './employees-list-item.css';

            class EmployeesListItem extends Component {

                constructor(props) {
                    super(props)
                    this.state = {
                        increase: false
                    }
                }

                onIncrease = () => {
                    this.setState( ({increase}) => ({
                        increase: !increase
                    }))
                }


                render() {
                    const { name, salary } = this.props
                    const { increase } = this.state

                    let classNames = "list-group-item d-flex justify-content-between"
                        if (increase) {
                            classNames += " increase"
                    }

                    return (
                        <li className={classNames}>
                            <span className="list-group-item-label">{name}</span>
                            <input type="text" className="list-group-item-input" defaultValue={salary + "$"} />
                            <div className='d-flex justify-content-center align-items-center'>
                                <button type="button"
                                    className="btn-cookie btn-sm "
                                    onClick={this.onIncrease}>
                                    <i className="fas fa-cookie"></i>
                                </button>

                                <button type="button"
                                    className="btn-trash btn-sm ">
                                    <i className="fas fa-trash"></i>
                                </button>
                                <i className="fas fa-star"></i>
                            </div>
                        </li>
                    )
                }
            }

            export default EmployeesListItem;



    На локальном уровне у нас все работает, но данные глобальные которые в App у нас пока не изменяются.


    //todo Дом. задание. - при клике на span с именем нужно добавлять класс like для этого юзера, тогда будет зажигаться 
    //todo третий значек - звездочка.

    
*/}


{/*    ====    17. Работа с формами, управляемые и неуправляемые компоненты     ====

    Формы в реакт очень похожи на аналоги в стандартной верстке, если не отменять стандартное поведение браузера то они будут
        перезагружать страницу. Отменять его в реакте можно только через event.preventDefault(). Все элементы форм поддерживают
        теже события(только onInput и onChange будут вести себя одинаково).


    
    Практиковаться с формой будем в файле addForm в проекте. Всё что будем вписывать в input должно сохраняться в нашем локальном
        state, поэтому переделаем компонент в классовый. В state будет два свойства - имя новосозданного сотрудника и количество
        денег - зарплата.

            this.state = {
                name: '',
                salary: ''  - //! строка потому что если установить 0 число то к нему добавляются цифры так как ввод строка
            }                  //! происходит конкатенация числа 0 со строкой ЕСЛИ инпут контролируемый

        Навесим обработчик события на оба инпута. И сделаем одну ф-ю для обоих обработчиков, смысл которой будет в том чтобы брать
        e.target.value и изменять необходимое свойство в state, это можно сделать с помощью ES6 синтаксиса. Так как мы не привязаны
        к тому что у нас хранится в свойстве до этого то делаем без коллбека. Сложность состоит в том как записать значение в нужное
        свойство. Для этого к инпутам добавим аттрибут name в котором будем указывать названия идентичные с названиями свойства в
        state, потом будем их брать и подставлять вместо названия изменяемого свойства как переменную, //! нужно обязательно брать в
        //! квадратные скобки чтобы не было ошибки.

            onValueChange = (e) => {
                this.setState({
                    [e.target.name]: e.target.value
                })
            }
        
            <input type="text"
                className="form-control new-post-label"
                placeholder="Как его зовут?"
                name='name'
                onChange={this.onValueChange} />
            <input type="number"
                className="form-control new-post-label"
                placeholder="З/П в $?"
                name='salary'
                onChange={this.onValueChange} />


        Эти инпуты у нас не управляемые(контролируемые) потому что значение вноситься только из инпута прямо в state но обратной
        связи нету. 
        
    
    
    Если нужно чтобы реакт компонент рендерил форму и контролировал её поведение в ответ на пользовательский ввод то нужно 
        добавить value = {} и в него помещать значение state. Такие элементы называются управляемыми.

            render() {
            const { name, salary } = this.state

            return (
                <div className="app-add-form">
                    <h3>Добавьте нового сотрудника</h3>
                    <form
                        className="add-form d-flex">
                        <input type="text"
                            className="form-control new-post-label"
                            placeholder="Как его зовут?"
                            name='name'
                            value={name}
                            onChange={this.onValueChange} />
                        <input type="number"
                            className="form-control new-post-label"
                            placeholder="З/П в $?"
                            name='salary'
                            value={salary}
                            onChange={this.onValueChange} />


        //! Зачем это делается - для синхронизации state с интерфейсом UI. Тоесть при вводе в инпут запускается setState который
        //! заново запустит render и при рендере значение будет браться не из поля, а из state. Это дает нам то что на все изменения
        //! интерфейс будет реагировать мгновенно, особенно это полезно при валидации данных, когда до момента записи в state данные
        //! проходят проверку на правильность и только тогда записываются в state. В основном используются именно такие контролируемые
        //! компоненты/елементы.

        //! Также существуют неуправляемые компоненты, значение которых храняться прямо в ДОМ дереве - тоесть в самом юзер интерфейсе,
        //! и это плохо потому что теряется возможность правильного использования инпутов и форм.

        //! Единственный инпут который в реакте всегда будет не управляемым - type='file' - позволяет юзеру загружать в него файл.
        //! так как файл в value отправить не можем))

        //todo есть приложенная статья на английском, но в конце там есть выводы можно почитать.
    
    
*/}


{/*    ====    18. Иммутабельность состояния, собственные события     ====

    Будем удалять сотрудников при нажимании на кнопку корзины. В реальном приложении когда сотрудник удалится со страницы он
        должен удалиться и на сервере(в базе данных). Чтобы удалился сотрудник нам нужно удалить его из данных. Сейчас иконка
        корзины находится в компоненте EmployeesListItem который не связан с данными которые лежат в App и чтобы связать их
        и отслеживать действия с ними нам нужно написать свои собственные события. Тогда если кликнем на корзинку на сотруднике
        он удалиться из данных они прийдут в компонент в котором рендерятся сотрудники, реакт увидит разницу и перерисует
        часть компонента которая изменилась.



    Откроем EmployeesList. Помним что как props мы можем передавать все что угодно, в том числе и ф-и. Передадим ф-ю в
        EmployeesListItem, она будет выводить в консоль сообщение - Deleted.

            return <EmployeesListItem 
                        key={id} 
                        { ...itemProps }
                        onDelete={() => console.log('Deleted')} />


        теперь можно ее использовать в компоненте EmployeesListItem, применим ее в компоненте на обработчик события,
        предварительно вытащив ее из props.

            const { name, salary, onDelete } = this.props

            <button type="button"
                className="btn-trash btn-sm "
                onClick={onDelete}>

            таким образом мы связали два компонента находящихся на разных уровнях иерархии - корневого и дочернего.


        Раз это работает с двумя элементами то передадим ф-ю из App в EmployeesList. Стрелочная ф-я которая будет
        получать какой то id и выводить его в консоль.

            <EmployeesList data={data} onDelete={id => console.log(id)}/>


        Теперь в EmployeesList будем использовать эту ф-ю предварительно достав ее из props и подставив вместо
        консольлога. И так как ф-я принимает один аргумент, то нужно ее вызвать с каким то аргументом. Тут мы
        как раз получали уникальный id для идентификации сотрудника(чтобы занести его в key), его и будем
        использовать.
        
            const EmployeesList = ({data, onDelete}) => {

            const elements = data.map( item => {
                const {id, ...itemProps} = item
                return <EmployeesListItem 
                        key={id} 
                        { ...itemProps }
                        onDelete={() => onDelete(id)} />

            теперь когда кликаем по корзине в консоль выводиться номер id сотрудника.


        Всё это произошло благодаря приему - передачи проперти(передачи свойств компонентов по иерархии) по научному это
        называется property drill - который рассмотрим позже. С самого верхнего компонента мы обозначили(написали) ф-ю
        передали дальше в компонент, там его вызвали с id(потому что тут есть id, а если вызвать в компоненте ниже то
        будет ошибка) и передали еще ниже и там она будет вызываться от клика юзера по кнопке. Таким образом можно
        передавать вниз и данные и методы и всё что угодно.

    

    На базе этого ф-ла приступим к удалению из массива данных data в App компоненте. Для динамической работы с 
        данными в реакте нам нужен state, в который и поместим эти данные. Переделываем App в классовый. data
        в нижний компонент теперь передаем из this.state.data. Ф-ю которую передавали теперь сделаем отдельным
        методом чтобы не писать код прямо при передаче, и чтобы иметь возможность его переиспользовать назовем
        его deleteItem. Теперь можно вместо консольлога работать с setState, сразу вытащим data из объекта
        state, но сразу возвращать объект не будем поэтому () эти скобки не ставим, а раскрывает фигурные
        скобки(тело ф-и) и будем выполнять в них определенные действия.

            class App extends Component {
            constructor(props) {
                super(props)
                this.state = {
                data: [
                    { name: "John C.", salary: 800, increase: true, id: 1 },
                    { name: "Alex M.", salary: 300, increase: true, id: 2 },
                    { name: "Carl W.", salary: 5000, increase: false, id: 3 }
                ]
                }
            }

            deleteItem = (id) => {
                this.setState(({data}) => {
                
                })
            }

            render() {
                return (
                <div className="app">
                    <AppInfo />

                    <div className="search-panel">
                    <SearchPanel />
                    <AppFilter />
                    </div>

                    <EmployeesList data={this.state.data} onDelete={this.deleteItem} />


        
        Алгоритм действий при удалении элемента из массива с объектами. Ориентироваться будем на id с которым
        этот метод вызывается. Теперь берем этот id и находим нужный объект внутри массива что бы его потом удалить.
        А потом будем изменять state чтобы созать новое состояние и запустить перерисовку компонента. id мы уже получили
        теперь рассмотрим как будем искать нужный объект. Это можно делать двумя способами:


        1) Находим индекс объекта в массиве по id через findIndex который вернет номер индекса объетка в котором нашел совпадения
        id, поместим его в переменную index и используем для удаления. 

            deleteItem = (id) => {
                this.setState(({data}) => {
                const index = data.findIndex(elem => elem.id === id)
                console.log(index)
                })
            }
        
            в консоль выводиться индекс елемента в массиве.

        теперь нужно удалить объект сохраняя иммутабельность state, тоесть state после создания не должен меняться и чтобы
        внести изменения создаем копию state вносим изменения в нее и присвоим эту копию как новый объект в state. Таким
        образом можно лего проследить что изменилось сравнивая новый и старый объект и это хорошо ложиться в концепцию
        реконцеляции(алгоритмов сравнения), также тестирование таких изменений будет легче. При таком подходе будет чуть
        больше расход памяти из-за создания множества объектов, но с характеристиками текущих гаджетов это не проблема.
        //todo приложена уникальная статья про иммутабельность в JS с примерами.

        //! Посмотрим как делать не нужно изменяя на прямую data в state. Методом splice просто удаляем елемент с полученым
        индексом, и вернем измененный объект чтобы setState его использовал. 
            
            deleteItem = (id) => {
                this.setState(({data}) => {
                const index = data.findIndex(elem => elem.id === id)
                data.splice(index, 1)
                return {
                    data: data
                }
                })
            }

            При нажатии на корзину сразу два сотрудника удаляются.
                
        Теперь как сделать правильно с использованием индекса - нужно создать новый массив который будет содержать все елементы
        старого массива но без того который удалим. Используем метод slice он копирует часть массива и создает новый. Скопируем
        часть до удаляемого элемента и после удаленного и склеим их в один массив. Первая переменная before будет копировать
        массив с начала(0 индекс) до полученого index, вторая переменная after будет копировать массив с index до конца.
        Потом их распакуем в новый массив и его вернем для присвоения data.

            deleteItem = (id) => {
                this.setState(({data}) => {
                const index = data.findIndex(elem => elem.id === id)

                const befor = data.slice(0, index)
                const after = data.slice(index + 1)

                const newArr = [ ...befor, ...after]

                return {
                    data: newArr
                }
                })
            }


            20 min

















    

    
*/}


{/*    ====    19. Практика. Подъем состояния     ====













    

    
*/}


{/*    ====    20. Реакт фрагменты     ====













    

    
*/}


{/*    ====    21. Практика. Реализуем поиск и фильтры     ====













    

    
*/}


{/*    ====    22. Семантика и доступность контента     ====













    

    
*/}


{/*    ====    23. Стили в React. Inline Styles     ====
 

    
*/}


{/*    ====    24. Стили в React. CSS и SASS/SCSS     ====
 

    
*/}


{/*    ====    25. Стили в React. Динамические классы и стили     ====
 

    
*/}


{/*    ====    26. Стили в React. Styled Components     ====
 

    
*/}


{/*    ====    27. Стили в React. Готовые библиотеки со стилями     ====
 

    
*/}


{/*    ====    28. Поля классов и static     ====
 

    
*/}


{/*    ====    29. Заключение модуля     ====
 

    
*/}



//==============================================  СРЕДНИЙ ФУНДАМЕНТАЛЬНЫЙ УРОВЕНЬ ==============================================\\

{/*    ====    01. Что такое API и как работают реальные приложения     ====
 
*/}


{/*    ====    02. Новый проект и работа с сервером     ====
 
*/}


{/*    ====    03. Трансформация данных и компонент со случайным персонажем     ====
 
*/}


{/*    ====    04. Хороший тон приложения (спиннер, ошибки...)     ====
 
*/}


{/*    ====    05. Жизненный цикл компонентов     ====
 
*/}


{/*    ====    06.  Практика с жизненным циклом, componentDidUpdate     ====
 
*/}


{/*    ====    07. Предохранители (Error Boundaries)     ====
 
*/}


{/*    ====    08. Пагинация данных (дозагрузка персонажей)     ====
 
*/}


{/*    ====    09. Проверка типов с помощью PropTypes     ====
 
*/}


{/*    ====    10. Вставка элементов через props.children     ====
 
*/}


{/*    ====    11. Специализация и наследование     ====
 
*/}


{/*    ====    12. Render-props паттерн     ====
 
*/}


{/*    ====    13. Что такое ref и зачем он нужен     ====
 
*/}


{/*    ====    14. Порталы     ====
 
*/}


{/*    ====    15. “Бандлинг” и выгрузка проекта на сервер     ====
 
*/}