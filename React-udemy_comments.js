{/*    ====    02. Что такое реакт     ====

    React нужен для оптимизации (в основном для веб приложений - обычные программы в браузере) и ускорения разработки.
        Стандартизация инструментов на рабочем месте для разных разработчиков.

    
*/}


{/*    ====    03. Принципы реакта (SPA)     ====

    Реакт - библиотека на основе JS, разработана facebook для упрощения разработки юзер интерфейсов. С помощью реакта можно
        создавать одностраничные приложения - SPA(single page application), изменяют страницу без перезагрузки, происходит 
        контроль использования памяти приложения.



    Принципы(плюсы) реакт:

        - Декларативный(говорит какой результат нам нужен) - создаем юзер интерфйсы в разных состояниях, а  обновлением состояний
            занимается реакт.

        - Основан на компонентах(повторяющиеся блоки) - компактные и независимые от другого кода для переиспользования где угодно и
            легкого тестирования

        - Реакт может работать на сервере(Node.js) и на мобильныз платформах(React Native)


        - Использует препроцессор JSX (удобное представление разметки в JS коде, писать js код можно прямо в ней)

        - Алгоритм сравнения(реконселейшн) - отслеживает какие части изменились и обновляет только их.

        - Virtual DOM
    
*/}


{/*    ====    04. Create React App (CRA)     ====

    CRA - настроенная сборка которая создается по вводу 1 строки кода в консоли среды разработки  -  npx create-react-app my-app
        
    cd my-app - зайти в папку с проектом

    npm start - запустить проект ( в режиме разработки)



    В nodemodules - все модули нужные для работы сборки. Основные - webpack - собирает проект, поддерживает хот релоад сервера, и
        Babel - компилирует JSX разметку, следит за поддержкой браузеров.

    Если включен плагин JShint нужно его отключить потому что он будет конфликтовать с подключенным по умолчанию в проекте
        ES lint и также он не понимает JSX будет подсвечивать ошибки.


    После запуска приложения в консоли браузера видим сообщение которое предлагает установить расширения для удобного дебаггинга,
        устанавливаем

    
*/}


{/*    ====    05. JSX, его ограничения     ====

    index.js - основной файл в котором ренедериться компонент с нашим приложением App.js. Если писать код в index то бывает
        что не происходит автоматическое обновление.

        //! Код в index может отличаться в зависимости от различных версий React 

    

    Первое что видим в файле это импорты. Если не указан путь то импортируется из папки node_modules. 

        Сначала импортируется React из модуля react - отвечает за работу реакта с JSX и внутренними возможностями.

        ReactDOM - позволяет работать с DOM структутрой на странице(вставлять реакт и приложение на страницу)

        import App from "./App" - компонент с приложением

        web Vitals - измеряет производительность приложения, можно удалить


    //! Март 22 вышел реакт 18. Теперь немного изменился index. ReactDOM теперь импортируется из 'react-dom/client' это спец. раздел
        который относится к клиентской части реакта, также изменился порядок команд, но принцип остался тот же. Если в index не 
        изменить код то просто не будут работать новые фишки 18 реакта и он будет работать как на предыдущей версии.

        Документация на английском актуальна для последнего обновления, рус версия может не успевать за ней.

        В курсе показан синтаксис 17 реакта.


        У ReactDOM вызывается метод render и передаются 2 аргумента, 1й - что - приложение которое рендериться, 2й - куда.
        //! Этот render должен вызываться только раз на самом верхнем уровне приложения( index ), бывают исключения. 
        Все остальное приложение собираем по отдельным файлам и заключаем в такую ф-ю как - App, его мы и будем предоставлять
        странице чтобы она нам его показала.



    //! В реакте до 17й версии для работы Babel нужно было импортировать React в каждый файл где есть jsx, после 17й версии 
        переписали код и теперь этого делать не нужно, импортируем только в index.js. При работе со старыми проектами если
        удалить импорты без апгрейда до новой версии реакта сломается проект.



    Реакт елемент - елемент интерфейса
        
            const elem = <h2>Hello</h2> 

        //! Если елемент большой(многострочный) нужно его оборачивать в скобки и у него всегда должен быть 1 родитель(обертка div)
        это связанно со способом создания элемента (создается один простой елемент а остальные елементы помещаются внутрь него как
        текст)  

            const elem = (
                <div>
                    <h2>Hello</h2>
                    <input type="text" />
                    <button />
                </div>
            ) 



    //! Чтобы в jsx работал emmet для создания тегов через таб нужно его донастроить(по умолчанию он не знает что в js файле можно
        вставлять верстку). Открываем настройки юзера - ctrl+, - сверху написано user, выбираем extensions -> emmet -> 
        include language -> add item  -> key - javascript, value - javascriptreact



    //! Главные правила елементов:
        - использовать скобки для многостроных элементов
        - один родитель для многострочного элемента
        - не забывать закрывать тег



    JSX позволяет вставлять внутрь себя код как при использования строки с обратными кавычками(бектиками) но без доллара

            <h2>Text: {text}</h2>

            return  <button>{ logged ? "Enter" : text }</button> - использование логического условия(//! тернарный оператор, if 
                                                                   не работает внутри таких фигурных в елементах)

        //! можно вставлять текст, мат операции,  свойства объектов, вызов ф-й/методов, КРОМЕ ОБЪЕКТОВ, тоесть нельзя поместить
        //! <h2>{new Date()}</h2> - будет ошибка, так сделано для безопасности кода, чтобы нельзя было помещать сторонние скрипты.
        //! В реакте все значения экранируются и переводяться встроки и когда запустится команда которая вернет объект то при 
        //! переводе будет просто 'object object'. С массивом будет работать но все елементы сконкатенируются.
        //! Правило именно для показа на на странице, передавать в props объекты можно, но перед показом на странице нужно из
        //! объекта вытащить содержимое.

          
        
    Аттрибуты css можно использовать с особенностями:
    
        - всегда пишуться в камел кейс если состоит более чем из 1 слова (исключения aria- , data-  -> aria-label)

                background-color  -> backgroundColor

                tabindex -> tabIndex

                <button tabIndex="0" >Click</button>


        - некоторые аттрибуты пишуться по своему в реакте потому что эти слова зарезервированы в JS

                class   ->  className

                for     ->  htmlFor

    
*/}


{/*    ====    06. Элементы и компоненты     ====

    Одна из основных концепций реакта - разбиение приложения на компоненты - функции которые могут возвращать JSX элементы,
        блоки юзер интерфейса которые могут иметь собственное поведение. Они могут переиспользоваться в разных местах кода и 
        состоят из элементов. 
        
        //! элементы в реакте неизменяемые, нельзя просто обратится к нему через класслист и добавить или
        удалить класс, назначить аттрибут. //! Чтобы изменить элемент нужно его полностью перерисовать на странице. В коде проводим
        операции что то изменяем, потом элемент проходит через виртуал дом и потом отрисовывается на странице взамен старого но уже
        с новыми параметрами. Можно в частных случаях напрямую обратиться к ДОМ элементу, но это используется очень редко.



    КОМПОНЕНТЫ правила:
        - всегда пишутся с большой буквы  <App/>
        - всегда есть return - чтоб возвращать JSX
        - если компонент слишком большой или его часть может использоваться в другой части кода, обладает логикой, нужно 
            выделить в отдельный компонент


        Чтобы использовать компонент в другом файле его нужно експортировать или по дефолту - тогда в другом файле можно при
        импорте назвать его по другому или именновано, тогда при импорте нужно указать именно то имя с которым файл експортировался.

        файл App
            export {Header};        или  добавляем перед самим елементом(ф-й) export function Btn() {...
            export default App;

        Файл индекс
            import { Header } from './App';
            import App from './App';        или  import MyApp from './App';



    Можно создавать через скобки как внутренности елементов, так и свойства тегов. //! В style вставлен созданный объект.
            const Field = () => {
                const holder = "Enter here"
                const styledField = {
                    width: '300px'
                }
                return <input placeholder={holder} type="text" style={styledField}/>
            }
        


    Классы в JS это теже ф-ии просто обернути в оболочку. Тоесть ф-и могут быть классами

            const Field = () => {
                const holder = "Enter here"
                const styledField = {
                    width: '300px'
                }
                return <input 
                        placeholder={holder} 
                        type="text" 
                        style={styledField}/>
            }

        перепишем как класс - для того чтобы они работали как задумано в реакте, нужно чтобы создаваемый класс унаследовал 
        поведение от родительского класса реакта. Для этого в файл импортируем реакт а потом из него достанем компонент с классом,
        если не нужно ничего конструировать то constructor не прописываем, но вклассовом компоненте должен быть как минимум 1 метод
        который будет что-то создавать (возвращать JSX) - render()
            
            import React from react;  -> const Field extends React.Component {

                или можно сразу вытащить компонент и не прописывать реакт каждый раз при создании классового компонента

            import {Component} from react;  -> const Field extends Component {

            const Field extends React.Component {
                render() {
                    const holder = "Enter here"
                    const styledField = {
                    width: '300px'
                    }
                    return <input 
                            placeholder={holder} 
                            type="text" 
                            style={styledField}/>
                }
            }
    

*/}


{/*    ====    07. Строгий режим     ====

    По функционалу он похож на strict mode в JS. Можно вытаскивать объекты реакта через запятую

            import React, {StrictMode, Component} from 'react';

            <StrictMode>
                <App />
            </StrictMode>


        Простым языком это компонент для обнаружения потенциальных проблем в приложении. Он ничего не рендерит и не заменяется 
        никаким другим компонентом, а существует внутри реакта - он активирует дополнительные проверки и предупреждения для потомков
        (вложенных в него компонентов), тоесть этот компонент можно использовать где угодно в приложении. Он помогает обнаруживать
        устаревшие и небезопасные конструкции и сообщает о некторых побочных эффектах. Эта возможность будет работать только в 
        режиме разработки.

        Это полезно в случаях: 
            - копирования чужого(устаревшего) кода 
            - когда нужно перевести приложение со старой версии реакта на новую, тогда можно быстро обнаружить те участки кода
                которые следует исправить перед переходом.

        Сообщения будут показываться в консоли браузера и в терминале.

    
*/}


{/*    ====    09. Создание нового проекта (практика)     ====

    Приложение учета сотрудников. Можно будет добавлять/удалять сотрудников, отмечать их, делать фильтраци(по размеру ЗП, 
        На повышение(чекбокс), имени - инпут). Это приложение показывает основные момента при работе с веб технологией 
        CRUD - Create Read Update Delete. Приложение - разновидность TODO - приложений которые часто дают на собеседованиях
        чтобы увидеть человек работает с этими базовыми концепциями. Заморачиваться стилями для приложения не будем - воспользуемся
        готовым набором классов которые будем подключать через CDN сервер (cdnjs.com).

        В этом уроке будем создавать структурную оболочку приложения - версткой разбитой на правильные компоненты и использующей
        правильные елементы по всем правилам из предыдущих уроков. Можно скачать по ссылке проект с готовой версткой и установить
        необходимые модули через npm i.
 


    Подключим бутстрап для задания готовых стилей через cdnjs.com - заходим на сайт, вбиваем bootstrap заходим в него и копируем
        в index ссылку на ксс стили, //! может понадобиться обновить ссылку потому что в видео другие версии, их можно выбирать на 
        сайте 

        в видео версия 5.1.1
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.2/css/bootstrap.min.css">
        
        для иконок делаем такуюже манипуляцию, в видео версия 5.15.4
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">



    Рассмотрим приложение, визуально делиться на 4 блока
        - хедер с информацией
        - блок фильтрации: поиск по имени + фильтры
        - список сотрудников
        - блок добавления нового сотрудника инпуты - имя + зарплата и кнопка добавить



    Начнем создавать такую структуру в проекте, в папку components будем складывать все остальные папки, использоваться для 
        именования будет кебаб стиль(через дефис)  employees-list-item , в каждой папке будет js(jsx - разницы нету) + css файл
        
            components
                app
                app-filter
                app-info
                employees-add-form
                employees-list
                employees-list-item
                search-panel

        
        Применение бутстрап стиля в компоненте - просто пишем название form-control и search-input - которые есть в бутстрапе и для 
        них соотносятся определенные стили

            const SearchPanel = () => {
                return (
                    <input type="text"
                            className="form-control search-input"


        
        Значение по умолчанию в реакте если не будет передано значение defaultValue

            <input type="text" className="list-group-item-input" defaultValue="1000$"/>


*/}


{/*    ====    10. Свойства компонентов - props    ====

    Свойства компонента(props) - предназначены для того чтобы заполнять контент компонента различным содержимым. Например если 
        имеется 10 карточек товара, то они будут однотипными по структуре и отличаются только содержимым, поэтому можно создать
        1 компонент - карточку и в props закидывать различное содержимое чтобы каждая карточка отображала свое.
        
            function WhoAmI (props) {
                return(
                    <div>
                    <h1>My name is {props.name}, surname - {props.surname}</h1>
                    <a href={props.link}>My profile</a>
                    </div>
                )
            }


            function App() {
                return (
                    <div className="App">
                    <WhoAmI name="John" surmane="Smith" link="facebook.com"/>
                    <WhoAmI name="Alex" surmane="Shepard" link="google.com"/>
                    </div>
                );
            }


        Можно сразу деструктуризировать - вытащив нужные свойства и тогда убрать слово props

             function WhoAmI ({name, surname, link}) {
               return(
                    <div>
                    <h1>My name is {name}, surname - {surname}</h1>


        //! В props можно передавать всё даже объекты и тогда прочитать нужно будет по name.firstName, потому что если оставить
        //! просто name то это будет объект и он не отобразиться напрямую на странице

            <WhoAmI name={{firstName: "John"}} surmane="Smith" link="facebook.com"/>

            function WhoAmI ({name, surname, link}) {
               return(
                    <div>
                    <h1>My name is {name.firstName}, surname - {surname}</h1>


        Функции - тогда в компоненте нужно будет вызвать эту ф-ю
                
            <WhoAmI name={ () => {return "John"} } surmane="Smith" link="facebook.com"/>

            function WhoAmI ({name, surname, link}) {
               return(
                    <div>
                    <h1>My name is { name() }, surname - {surname}</h1>



        //! Главное правило реакта что props внутри компонента не должны изменяться(иммутабельность).

    
*/}


{/*    ====    11. Практика свойств на проекте     ====

    Сделаем кастомизацию сотрудников( пока что 3 Джона Смита с одинаковой ЗП). Передадим props в компонент EmployeesListItem и 

            <EmployeesListItem name="John C." salary={800} />

        модифицируем его для работы с ними

            const EmployeesListItem = ({name, salary}) => {
                return (
                    <li className="list-group-item d-flex justify-content-between">
                        <span className="list-group-item-label">{name}</span>
                        <input type="text" className="list-group-item-input" defaultValue={salary + "$"}/>



    Теперь карточки сотрудников отличаются, но данные захардкожены(жестко зафиксированы) и если будет 1000 сотрудников нужно будет 
        вносить все данные руками. Чтобы такого не делать поработаем с данными, допустим с сервера они пришли в компонент App и 
        сохранились, создадим их там в формате массива который содержит объекты в которых есть свойства name и salary. И передадим
        их как свойства в нужный компонент EmployeesList. 

            function App() {
                const data = [
                    {name: "John C.", salary: 800},
                    {name: "Alex M.", salary: 300},
                    {name: "Carl W.", salary: 5000}
                ]

                <EmployeesList data={data}/>


        Теперь можем использовать данные которые пришли в props, но снова нужно будет вбивать все вручную например так
                
                <EmployeesListItem name={data[0].name} salary={data[0].salary} />

            и чтобы так не делать используем метод перебора массива map который при переборе возвращает НОВЫЙ массив елементов в 
            каждый подставляя свойства из каждого объекта предыдущего массива, а значит придерживается правила иммутабельности не 
            изменяя входящие данные, и потом нужно просто вывести на страницу этот массив с элементами.

                const EmployeesList = ({data}) => {
                    const elements = data.map( item => {
                        return <EmployeesListItem name={item.name} salary={item.salary} />
                    })

                    return (
                        <ul className="app-list list-group">
                            {elements}
                        </ul>
                    )
                }
                            
            Теперь список сотрудников формируется динамически.

            //! Можно улучшить запись добавлением спред оператора, тоесть при name={item.name} - мы вытаскиваем значение name из 
            объекта item и дальше также вытаскиваем salary, по сути мы присваиваем name = name и так как названия не меняются
            можно просто сдлать спред оператор который сам распакует нам названия со значением что преарвтит объект
            {name: "John C.", salary: 800} в строку  - name: "John C.", salary: 800

                return <EmployeesListItem { ...item } />

    
*/}


{/*    ====    12. Работа со списками и алгоритм согласования     ====

    В консоли вылезла ошибка что каждый елемент списка должен иметь уникальное свойство ключ - "key".

    Процесс создания дом дерева затратный по ресурсам, на помощь ему приходит виртуал ДОМ. Но его построение тоже не очень
        дешево если используется много элементов, например список из 200 строк и одна в середине удалилась как в таком случае
        отработает приложение, тут и сработает механизм согласования(сверки, реконцеляции).  Или вместо корневого для
        списка тега li он измениться на div то реакт не изменяет узел а уничтожает его и создает заново вместе со списком из
        200 объектов, но если поменяется только стили у тега, то внутренности не будут уничтожены, а пресоздасться только корневой
        тег с новыми стилями и рекурсивно реакт пойдет смотреть есть ли отличия старого дерева объектов от новго который реакт
        создаст при выявлении отличий реакт перерисует в реальном ДОМ дереве только те елементы которые изменились.

        На базовом уровне сравнение списка идет по порядку, начиная с первого. Если елемент добавляется в конец то реакт пройдет
        по всему списку увидит что елементы одинаковые, найдет последний новый елемент и дорисует его. Но если мы помещаем новый
        елемент в начало списка, то он теперь будет первым и не будет равен предидущему первому, а предыдущий первый станет вторым
        и не будет равен старому второму, таким образом прийдется перерисовывать все елементы. Чтобы реакт быстрее сравнивал(имел
        какую то привязку, видел что элемент тот же и в нем ничего не изменилось) используют key и именно по нему реакт будет
        определять изменился елемент или нет. //! Ключи должны быть уникальными только среди своего списка. Если с сервера не пришел
        //! id (не написали) то допускается использование индекса элемента как ключа но такое допускается только если не будет
        //! меняться порядок элементов. Плохая практика использование для ключей ф-й по типу Math.random



    Захардкодим уникальные id в data
        
            const data = [
                {name: "John C.", salary: 800, increase: true, id: 1},
                {name: "Alex M.", salary: 300, increase: true, id: 2},
                {name: "Carl W.", salary: 5000, increase: false, id: 3}
            ]

        и в методе map будем использовать их как ключи, так как названия у нас не совпадают тоесть у нас будет key = id то нужно
        вытащить их отдельно для этого сделаем частичную деструктуризацию вытащив id, а остальные свойства сохраним в itemProps
        который деструктуризируем как раньше item

            const elements = data.map( item => {
                const {id, ...itemProps} = item
                return <EmployeesListItem key={id} { ...itemProps } />
            })
  
    
*/}


{/*    ====    13. Состояния компонентов     ====













    

    
*/}