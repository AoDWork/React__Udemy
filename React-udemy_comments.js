//==============================================  БАЗОВЫЙ УРОВЕНЬ ==============================================\\

{/*    ====    02. Что такое реакт     ====

    React нужен для оптимизации (в основном для веб приложений - обычные программы в браузере) и ускорения разработки.
        Стандартизация инструментов на рабочем месте для разных разработчиков.

    
*/}

{/*    ====    03. Принципы реакта (SPA)     ====

    Реакт - библиотека на основе JS, разработана facebook для упрощения разработки юзер интерфейсов. С помощью реакта можно
        создавать одностраничные приложения - SPA(single page application), изменяют страницу без перезагрузки, происходит 
        контроль использования памяти приложения.



    Принципы(плюсы) реакт:

        - Декларативный(говорит какой результат нам нужен) - создаем юзер интерфйсы в разных состояниях, а  обновлением состояний
            занимается реакт.

        - Основан на компонентах(повторяющиеся блоки) - компактные и независимые от другого кода для переиспользования где угодно и
            легкого тестирования

        - Реакт может работать на сервере(Node.js) и на мобильныз платформах(React Native)


        - Использует препроцессор JSX (удобное представление разметки в JS коде, писать js код можно прямо в ней)

        - Алгоритм сравнения(реконселейшн) - отслеживает какие части изменились и обновляет только их.

        - Virtual DOM
    

*/}

{/*    ====    04. Create React App (CRA)     ====

    CRA - настроенная сборка которая создается по вводу 1 строки кода в консоли среды разработки  -  npx create-react-app my-app
        
    cd my-app - зайти в папку с проектом

    npm start - запустить проект ( в режиме разработки)



    В nodemodules - все модули нужные для работы сборки. Основные - webpack - собирает проект, поддерживает хот релоад сервера, и
        Babel - компилирует JSX разметку, следит за поддержкой браузеров.

    Если включен плагин JShint нужно его отключить потому что он будет конфликтовать с подключенным по умолчанию в проекте
        ES lint и также он не понимает JSX будет подсвечивать ошибки.


    После запуска приложения в консоли браузера видим сообщение которое предлагает установить расширения для удобного дебаггинга,
        устанавливаем

    
*/}

{/*    ====    05. JSX, его ограничения     ====

    index.js - основной файл в котором ренедериться компонент с нашим приложением App.js. Если писать код в index то бывает
        что не происходит автоматическое обновление.

        //! Код в index может отличаться в зависимости от различных версий React 

    

    Первое что видим в файле это импорты. Если не указан путь то импортируется из папки node_modules. 

        Сначала импортируется React из модуля react - отвечает за работу реакта с JSX и внутренними возможностями.

        ReactDOM - позволяет работать с DOM структутрой на странице(вставлять реакт и приложение на страницу)

        import App from "./App" - компонент с приложением

        web Vitals - измеряет производительность приложения, можно удалить


    //! Март 22 вышел реакт 18. Теперь немного изменился index. ReactDOM теперь импортируется из 'react-dom/client' это спец. раздел
        который относится к клиентской части реакта, также изменился порядок команд, но принцип остался тот же. Если в index не 
        изменить код то просто не будут работать новые фишки 18 реакта и он будет работать как на предыдущей версии.

        Документация на английском актуальна для последнего обновления, рус версия может не успевать за ней.

        В курсе показан синтаксис 17 реакта.


        У ReactDOM вызывается метод render и передаются 2 аргумента, 1й - что - приложение которое рендериться, 2й - куда.
        //! Этот render должен вызываться только раз на самом верхнем уровне приложения( index ), бывают исключения. 
        Все остальное приложение собираем по отдельным файлам и заключаем в такую ф-ю как - App, его мы и будем предоставлять
        странице чтобы она нам его показала.



    //! В реакте до 17й версии для работы Babel нужно было импортировать React в каждый файл где есть jsx, после 17й версии 
        переписали код и теперь этого делать не нужно, импортируем только в index.js. При работе со старыми проектами если
        удалить импорты без апгрейда до новой версии реакта сломается проект.



    Реакт елемент - елемент интерфейса
        
            const elem = <h2>Hello</h2> 

        //! Если елемент большой(многострочный) нужно его оборачивать в скобки и у него всегда должен быть 1 родитель(обертка div)
        это связанно со способом создания элемента (создается один простой елемент а остальные елементы помещаются внутрь него как
        текст)  

            const elem = (
                <div>
                    <h2>Hello</h2>
                    <input type="text" />
                    <button />
                </div>
            ) 



    //! Чтобы в jsx работал emmet для создания тегов через таб нужно его донастроить(по умолчанию он не знает что в js файле можно
        вставлять верстку). Открываем настройки юзера - ctrl+, - сверху написано user, выбираем extensions -> emmet -> 
        include language -> add item  -> key - javascript, value - javascriptreact



    //! Главные правила елементов:
        - использовать скобки для многостроных элементов
        - один родитель для многострочного элемента
        - не забывать закрывать тег



    JSX позволяет вставлять внутрь себя код как при использования строки с обратными кавычками(бектиками) но без доллара

            <h2>Text: {text}</h2>

            return  <button>{ logged ? "Enter" : text }</button> - использование логического условия(//! тернарный оператор, if 
                                                                   не работает внутри таких фигурных в елементах)

        //! можно вставлять текст, мат операции,  свойства объектов, вызов ф-й/методов, КРОМЕ ОБЪЕКТОВ, тоесть нельзя поместить
        //! <h2>{new Date()}</h2> - будет ошибка, так сделано для безопасности кода, чтобы нельзя было помещать сторонние скрипты.
        //! В реакте все значения экранируются и переводяться встроки и когда запустится команда которая вернет объект то при 
        //! переводе будет просто 'object object'. С массивом будет работать но все елементы сконкатенируются.
        //! Правило именно для показа на на странице, передавать в props объекты можно, но перед показом на странице нужно из
        //! объекта вытащить содержимое.

          
        
    Аттрибуты css можно использовать с особенностями:
    
        - всегда пишуться в камел кейс если состоит более чем из 1 слова (исключения aria- , data-  -> aria-label)

                background-color  -> backgroundColor

                tabindex -> tabIndex

                <button tabIndex="0" >Click</button>


        - некоторые аттрибуты пишуться по своему в реакте потому что эти слова зарезервированы в JS

                class   ->  className

                for     ->  htmlFor

    
*/}

{/*    ====    06. Элементы и компоненты     ====

    Одна из основных концепций реакта - разбиение приложения на компоненты - функции которые могут возвращать JSX элементы,
        блоки юзер интерфейса которые могут иметь собственное поведение. Они могут переиспользоваться в разных местах кода и 
        состоят из элементов. 
        
        //! элементы в реакте неизменяемые, нельзя просто обратится к нему через класслист и добавить или
        удалить класс, назначить аттрибут. //! Чтобы изменить элемент нужно его полностью перерисовать на странице. В коде проводим
        операции что то изменяем, потом элемент проходит через виртуал дом и потом отрисовывается на странице взамен старого но уже
        с новыми параметрами. Можно в частных случаях напрямую обратиться к ДОМ элементу, но это используется очень редко.



    КОМПОНЕНТЫ правила:
        - всегда пишутся с большой буквы  <App/>
        - всегда есть return - чтоб возвращать JSX
        - если компонент слишком большой или его часть может использоваться в другой части кода, обладает логикой, нужно 
            выделить в отдельный компонент


        Чтобы использовать компонент в другом файле его нужно експортировать или по дефолту - тогда в другом файле можно при
        импорте назвать его по другому или именновано, тогда при импорте нужно указать именно то имя с которым файл експортировался.

        файл App
            export {Header};        или  добавляем перед самим елементом(ф-й) export function Btn() {...
            export default App;

        Файл индекс
            import { Header } from './App';
            import App from './App';        или  import MyApp from './App';



    Можно создавать через скобки как внутренности елементов, так и свойства тегов. //! В style вставлен созданный объект.
            const Field = () => {
                const holder = "Enter here"
                const styledField = {
                    width: '300px'
                }
                return <input placeholder={holder} type="text" style={styledField}/>
            }
        


    Классы в JS это теже ф-ии просто обернути в оболочку. Тоесть ф-и могут быть классами

            const Field = () => {
                const holder = "Enter here"
                const styledField = {
                    width: '300px'
                }
                return <input 
                        placeholder={holder} 
                        type="text" 
                        style={styledField}/>
            }

        перепишем как класс - для того чтобы они работали как задумано в реакте, нужно чтобы создаваемый класс унаследовал 
        поведение от родительского класса реакта. Для этого в файл импортируем реакт а потом из него достанем компонент с классом,
        если не нужно ничего конструировать то constructor не прописываем, но вклассовом компоненте должен быть как минимум 1 метод
        который будет что-то создавать (возвращать JSX) - render()
            
            import React from react;  -> const Field extends React.Component {

                или можно сразу вытащить компонент и не прописывать реакт каждый раз при создании классового компонента

            import {Component} from react;  -> const Field extends Component {

            const Field extends React.Component {
                render() {
                    const holder = "Enter here"
                    const styledField = {
                    width: '300px'
                    }
                    return <input 
                            placeholder={holder} 
                            type="text" 
                            style={styledField}/>
                }
            }
    

*/}

{/*    ====    07. Строгий режим     ====

    По функционалу он похож на strict mode в JS. Можно вытаскивать объекты реакта через запятую

            import React, {StrictMode, Component} from 'react';

            <StrictMode>
                <App />
            </StrictMode>


        Простым языком это компонент для обнаружения потенциальных проблем в приложении. Он ничего не рендерит и не заменяется 
        никаким другим компонентом, а существует внутри реакта - он активирует дополнительные проверки и предупреждения для потомков
        (вложенных в него компонентов), тоесть этот компонент можно использовать где угодно в приложении. Он помогает обнаруживать
        устаревшие и небезопасные конструкции и сообщает о некторых побочных эффектах. Эта возможность будет работать только в 
        режиме разработки.

        Это полезно в случаях: 
            - копирования чужого(устаревшего) кода 
            - когда нужно перевести приложение со старой версии реакта на новую, тогда можно быстро обнаружить те участки кода
                которые следует исправить перед переходом.

        Сообщения будут показываться в консоли браузера и в терминале.

    
*/}

{/*    ====    09. Создание нового проекта (практика)     ====

    Приложение учета сотрудников. Можно будет добавлять/удалять сотрудников, отмечать их, делать фильтраци(по размеру ЗП, 
        На повышение(чекбокс), имени - инпут). Это приложение показывает основные момента при работе с веб технологией 
        CRUD - Create Read Update Delete. Приложение - разновидность TODO - приложений которые часто дают на собеседованиях
        чтобы увидеть человек работает с этими базовыми концепциями. Заморачиваться стилями для приложения не будем - воспользуемся
        готовым набором классов которые будем подключать через CDN сервер (cdnjs.com).

        В этом уроке будем создавать структурную оболочку приложения - версткой разбитой на правильные компоненты и использующей
        правильные елементы по всем правилам из предыдущих уроков. Можно скачать по ссылке проект с готовой версткой и установить
        необходимые модули через npm i.
 


    Подключим бутстрап для задания готовых стилей через cdnjs.com - заходим на сайт, вбиваем bootstrap заходим в него и копируем
        в index ссылку на ксс стили, //! может понадобиться обновить ссылку потому что в видео другие версии, их можно выбирать на 
        сайте 

        в видео версия 5.1.1
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.2/css/bootstrap.min.css">
        
        для иконок делаем такуюже манипуляцию, в видео версия 5.15.4
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">



    Рассмотрим приложение, визуально делиться на 4 блока
        - хедер с информацией
        - блок фильтрации: поиск по имени + фильтры
        - список сотрудников
        - блок добавления нового сотрудника инпуты - имя + зарплата и кнопка добавить



    Начнем создавать такую структуру в проекте, в папку components будем складывать все остальные папки, использоваться для 
        именования будет кебаб стиль(через дефис)  employees-list-item , в каждой папке будет js(jsx - разницы нету) + css файл
        
            components
                app
                app-filter
                app-info
                employees-add-form
                employees-list
                employees-list-item
                search-panel

        
        Применение бутстрап стиля в компоненте - просто пишем название form-control и search-input - которые есть в бутстрапе и для 
        них соотносятся определенные стили

            const SearchPanel = () => {
                return (
                    <input type="text"
                            className="form-control search-input"


        
        Значение по умолчанию в реакте если не будет передано значение defaultValue

            <input type="text" className="list-group-item-input" defaultValue="1000$"/>


*/}

{/*    ====    10. Свойства компонентов - props    ====

    Свойства компонента(props) - предназначены для того чтобы заполнять контент компонента различным содержимым. Например если 
        имеется 10 карточек товара, то они будут однотипными по структуре и отличаются только содержимым, поэтому можно создать
        1 компонент - карточку и в props закидывать различное содержимое чтобы каждая карточка отображала свое.
        
            function WhoAmI (props) {
                return(
                    <div>
                    <h1>My name is {props.name}, surname - {props.surname}</h1>
                    <a href={props.link}>My profile</a>
                    </div>
                )
            }


            function App() {
                return (
                    <div className="App">
                    <WhoAmI name="John" surmane="Smith" link="facebook.com"/>
                    <WhoAmI name="Alex" surmane="Shepard" link="google.com"/>
                    </div>
                );
            }


        Можно сразу деструктуризировать - вытащив нужные свойства и тогда убрать слово props

             function WhoAmI ({name, surname, link}) {
               return(
                    <div>
                    <h1>My name is {name}, surname - {surname}</h1>


        //! В props можно передавать всё даже объекты и тогда прочитать нужно будет по name.firstName, потому что если оставить
        //! просто name то это будет объект и он не отобразиться напрямую на странице

            <WhoAmI name={{firstName: "John"}} surmane="Smith" link="facebook.com"/>

            function WhoAmI ({name, surname, link}) {
               return(
                    <div>
                    <h1>My name is {name.firstName}, surname - {surname}</h1>


        Функции - тогда в компоненте нужно будет вызвать эту ф-ю
                
            <WhoAmI name={ () => {return "John"} } surmane="Smith" link="facebook.com"/>

            function WhoAmI ({name, surname, link}) {
               return(
                    <div>
                    <h1>My name is { name() }, surname - {surname}</h1>



        //! Главное правило реакта что props внутри компонента не должны изменяться(иммутабельность).

    
*/}

{/*    ====    11. Практика свойств на проекте     ====

    Сделаем кастомизацию сотрудников( пока что 3 Джона Смита с одинаковой ЗП). Передадим props в компонент EmployeesListItem и 

            <EmployeesListItem name="John C." salary={800} />

        модифицируем его для работы с ними

            const EmployeesListItem = ({name, salary}) => {
                return (
                    <li className="list-group-item d-flex justify-content-between">
                        <span className="list-group-item-label">{name}</span>
                        <input type="text" className="list-group-item-input" defaultValue={salary + "$"}/>



    Теперь карточки сотрудников отличаются, но данные захардкожены(жестко зафиксированы) и если будет 1000 сотрудников нужно будет 
        вносить все данные руками. Чтобы такого не делать поработаем с данными, допустим с сервера они пришли в компонент App и 
        сохранились, создадим их там в формате массива который содержит объекты в которых есть свойства name и salary. И передадим
        их как свойства в нужный компонент EmployeesList. 

            function App() {
                const data = [
                    {name: "John C.", salary: 800},
                    {name: "Alex M.", salary: 300},
                    {name: "Carl W.", salary: 5000}
                ]

                <EmployeesList data={data}/>


        Теперь можем использовать данные которые пришли в props, но снова нужно будет вбивать все вручную например так
                
                <EmployeesListItem name={data[0].name} salary={data[0].salary} />

            и чтобы так не делать используем метод перебора массива map который при переборе возвращает НОВЫЙ массив объекто в 
            каждый объект поместив элемент JSX c свойствами из аналогичного(по порядку) объекта предыдущего массива, а значит 
            придерживается правила иммутабельности не изменять входящие данные, получим новый массив с элементами jsx и потом его
            выведем на страницу.

                const EmployeesList = ({data}) => {
                    
                    const elements = data.map( item => {
                        return <EmployeesListItem name={item.name} salary={item.salary} />
                    })

                    return (
                        <ul className="app-list list-group">
                            {elements}
                        </ul>
                    )
                }
                            
            Теперь список сотрудников формируется динамически.

            //! Можно улучшить запись добавлением спред оператора, тоесть при name={item.name} - мы вытаскиваем значение name из 
            объекта item и дальше также вытаскиваем salary, по сути мы присваиваем name = name и так как названия не меняются
            можно просто сделать спред оператор который сам распакует нам названия со значением что превратит объект
            {name: "John C.", salary: 800} в строку  - name: "John C.", salary: 800

                return <EmployeesListItem { ...item } />

    
*/}

{/*    ====    12. Работа со списками и алгоритм согласования     ====

    В консоли вылезла ошибка что каждый елемент списка должен иметь уникальное свойство ключ - "key".

    Процесс создания дом дерева затратный по ресурсам, на помощь ему приходит виртуал ДОМ. Но его построение тоже не очень
        дешево если используется много элементов, например список из 200 строк и одна в середине удалилась как в таком случае
        отработает приложение, тут и сработает механизм согласования(сверки, реконцеляции).  Или вместо корневого для
        списка тега li он измениться на div то реакт не изменяет узел а уничтожает его и создает заново вместе со списком из
        200 объектов, но если поменяется только стили у тега, то внутренности не будут уничтожены, а пресоздасться только корневой
        тег с новыми стилями и рекурсивно реакт пойдет смотреть есть ли отличия старого дерева объектов от новго который реакт
        создаст при выявлении отличий реакт перерисует в реальном ДОМ дереве только те елементы которые изменились.

        На базовом уровне сравнение списка идет по порядку, начиная с первого. Если елемент добавляется в конец то реакт пройдет
        по всему списку увидит что елементы одинаковые, найдет последний новый елемент и дорисует его. Но если мы помещаем новый
        елемент в начало списка, то он теперь будет первым и не будет равен предидущему первому, а предыдущий первый станет вторым
        и не будет равен старому второму, таким образом прийдется перерисовывать все елементы. Чтобы реакт быстрее сравнивал(имел
        какую то привязку, видел что элемент тот же и в нем ничего не изменилось) используют key и именно по нему реакт будет
        определять изменился елемент или нет. //! Ключи должны быть уникальными только среди своего списка. Если с сервера не пришел
        //! id (не написали) то допускается использование индекса элемента как ключа но такое допускается только если не будет
        //! меняться порядок элементов. Плохая практика использование для ключей ф-й по типу Math.random



    Захардкодим уникальные id в data
        
            const data = [
                {name: "John C.", salary: 800, increase: true, id: 1},
                {name: "Alex M.", salary: 300, increase: true, id: 2},
                {name: "Carl W.", salary: 5000, increase: false, id: 3}
            ]

        и в методе map будем использовать их как ключи, так как названия у нас не совпадают тоесть у нас будет key = id то нужно
        вытащить их отдельно для этого сделаем частичную деструктуризацию вытащив id, а остальные свойства сохраним в itemProps
        который деструктуризируем как раньше item

            const elements = data.map( item => {
                const {id, ...itemProps} = item
                return <EmployeesListItem key={id} { ...itemProps } />
            })
  
    
*/}

{/*    ====    13. Состояния компонентов     ====

    Состояние компонента(state) может динамически изменяться в отличие от свойств(например цифра в компоненте счетчике или номер 
        активного слайда в слайдере). Изначально состояние можно было создать только в классовом компоненте, потом с введение хуков
        такая возможность появилась и в функциональном. Поэтому рассмотрим state на примере классового компонента, чтобы понимать
        как оно работает.



    Продолжим в App переделав ф-й компонент WhoAmI в классовый. 

            function WhoAmI ({name, surname, link}) {
                return(
                    <div>
                    <h1>My name is {name}, surname - {surname}</h1>
                    <a href={link}>My profile</a>
                    </div>
                )
            }


        Для этого импортируем компонент из реакта. //! Когда класс вызывается он создает свой экземпляр и чтобы в него передались
        props нужно использовать конструктор, в нем принять эти props и чтобы их использовать пропишем слово супер и в него 
        передадим props. Эта возможность работы с prop приходит из Component от которого и наследуется наш классовый компонент.
        Теперь внутри каждого экземпляра класса будет свойство this.props - с объектом props(то что мы туда передали). Чтобы 
        каждый раз не писать this сделаем деструктуризацию в render и вытащим свойства из него.

            import { Component } from react;

            class WhoAmI extends Component {
                constructor(props) {
                    super(props)
                }
                render() {
                    const {name, surname, link} = this.props
                    return(
                    <div>
                        <h1>My name is {name}, surname - {surname}</h1>
                        <a href={link}>My profile</a>
                    </div >
                    )
                }
            }

        //! В консоле предупреждение о бесполезном конструкторе, так как мы тудеа ничего своего не добавили то его можно просто
        удалить. Но пока оставим его что бы знать что он нужен если мы захотим добавить в компонент свое поведение(ф-и или state).



    Так как props менять мы не должны то для того чтобы ввести динамику создадим свойство state в конструкторе - это такой объект
        в котором храняться различные свойства которые будут динамически изменяться. //! В нем можно делать много свойств и дописывать
        вложенные структуры. Используем значение years в компоненте обратившись как к обычному свойству в объекте this.state.years

            constructor(props) {
                super(props)
                this.state = {
                    years: 27
                }
            }


            <h1>My name is {name}, surname - {surname}, age - {this.state.years}</h1>



    Добавим кнопку с событием в компонент для смены значения свойства years. Передаем в onClick только название ф-и без вызова, 
        вызываться будет когда юзер будет кликать по кнопке. Теперь создадим этот метод через стрелочную ф-ю, //! через обычную
        ф-ю будет ошибка ???  - рассмотрим в следующих уроках. Видим что кнопка появилась для каждого компонента своя.

            nextYear = () => {
            }

            <button onClick={this.nextYear}>+++</button>



    Напрямую изменить(мутировать) state нельзя, тоесть нельзя написать this.state.years++ - не будет происходить изменение, для 
        этого нужно использовать комманду(ф-ю)  this.setState() - в себя она принимает аргумент - объект с новым состоянием(объектом)
        который прямо тут и конструируем - записываем свойство years в котором будет текущее состояние this.state.years - увеличиное
        на один, инкримент ++ - помещаем в префиксной форме - перед значением.

            nextYear = () => {
                this.setState({
                years: ++this.state.years
                })
            }


        теперь при нажатии на кнопку изменяется текст age компонента, причем для каждого компонента цифра храниться своя.
        //! Но видим что предупреждение о мутации в консоли не пропало, потому что мы снова меняем напрямую предыдущий state
        //! оператором ++, поэтому для увеличения или уменьшения используется такая запись  years: this.state.years + 1

            nextYear = () => {
                this.setState({
                years: this.state.years + 1
                })
            }



    //! Когда запускается setState - она производит перерисовку(запускает метод render) всего компонента с новым состоянием. 
    //! setState выполняется асинхронно и state в 95% случаев зависит от предыдущего state, тоесть когда увличивается с 30 до 31
    //! счетчик то мы знаем что перед 31 предыдущее состояние должно быть только 30 чтобы получить правильный результат. А из-за
    //! асинхронности может получиться так что предыдушее состояние еще не обновилось, а мы уже снова обновляем. Тоесть если 
    //! сейчас очень быстро клацать кнопку то может случиться так что счетчик собЪется и результат будет не таким как нам нужен.
    
    //! Так получается потому что несколько изменений состояний объединяются в одно и приоритет выполнения может быть отдан 
    //! другому работающему процессу и будет ждать его завершения, такая у реакта оптимизация работы.

    //! Чтобы от этого избавиться можно внутрь setState передать другую ф-ю тоесть коллбек, таким образом реакт будет ждать 
    //! выполнения предыдущего коллбека перед выполнением следующего. При этом ф-я принимает текущее состояние state и вместо записи 
    //! return мы берем в круглые скобки весь объект который она возвращает, и так как у нас state уже приходит без this, нам больше 
    //! не нужно его вытягивать из объекта и можно this удалить.

            nextYear = () => {
                this.setState(state => ({
                    years: state.years + 1
                }))
            }

        //! Если state не зависит от предыдущего, например вводиться в инпут новое значение которое не зависит от старого значения
        то можно передавать просто объект.



    //! В state может быть больше чем 1 свойство, возникает вопрос что будет с другими свойствами раз мы в setState указали только
    //! одно. setState меняет в state только то что мы указали, а остальное остается неизменным и не стирается.

    
*/}

{/*    ====    14. Самостоятельное задание на работу с состоянием     ====

    Домашнее задание по ссылке https://codepen.io/ihinstone/pen/QWvYePv

    
*/}

{/*    ====    15. События в реакт, вспоминаем this     ====

    onClick мы уже использовали, рассмотрим остальные с базовых понятий, продолжаем на проекте из 13 урока.

    Для назначения обработчика события в реакте прописываем событие в качестве аргумента в формате camelCase. Создадим форму с
        инпутом и создадим у него обработчик событий onInput. //! В JS onInput срабатывает когда впечатывается что то в инпут, а
        //! onChange - когда уводится фокус от элемента. В реакте они работают одинаково и зачастую используют onChange.
        Создадим и положим в него метод commitInputChanges, хотим чтобы при впечатывании текста он попадал в state. Для этого
        в state создадим свойство position(должность). Также вынесем в отдельные переменные position и years чтобы не писать
        часто this.state. //! addEventListener вызывать нигде не нужно реакт все делает сам когда компоненту или елементу
        //! назначаем событие. Для отмены стандартного поведения браузера в реакт работает только  event.preventDefault(); другие
        //! методы такие как return false в реакте работать не будут


             commitInputChanges = (e) => {
                this.setState({
                    position: e.target.value
                })
            }

            render() {
                const { name, surname, link } = this.props
                const {position, years} = this.state
                return (
                <div>
                    <button onClick={this.nextYear}>{this.state.text}</button>
                    <h1>My name is {name}, surname - {surname}, 
                        age - {years}, 
                        position - {position}</h1>
                    <a href={link}>My profile</a>
                    <form>
                    <span>Введите должность</span>
                    <input type="text" onChange={this.commitInputChanges} />
                    </form>
                </div >
                )
            }
            }

        

    //! Для методов всегда нужно использовать СТРЕЛОЧНЫЕ ф-и. Потому что this свой для каждого екземпляра класса(объекта созданного из
    //! этого класса). Когда работает с props и state тут всегда будет ссылка на данный екземпляр. А с обработчиками события сложнее
    //! когда событие срабатывает - контекст теряется, из-за того что ф-я события вызывается внутри другой ф-и - render при этом
    //! this становиться undefined и если просто сделать из стрелочной ф-и обычную то будет ошибка - не могу прочитать свойство у
    //! undefined когда выполняется setState, на этом этапе он и теряется. Ф-я setState вызывается внутри ф-и nextYear а она 
    //! вызывается внутри render.

             nextYear () {
                this.setState(state => ({
                    years: state.years + 1
                }))
            }


    //! Разберем все 3 варианта как избежать данной проблемы:

        //! 1) через bind. Прописываем в конструкторе эту строку  this.nextYear = this.nextYear.bind(this)
        //! Слева будет обычное свойство которое будет у екземпляра класса который был создан.
        //! С права обращаемся к методу this.nextYear - которые есть в классе и мы его байндим(привязываем)
        //! к конкретному екземпляру класса .bind(this). Если по простому то мы жестко привязываем метод из родительского класса к 
        //! созданному екземпляру. Так будет работать с конструкцией выше. 


            constructor(props) {
                super(props)
                this.state = {
                    years: 27,
                    text: '+++',
                    position: ''
                }
                this.nextYear = this.nextYear.bind(this)
            }

            //! неудобство в том что каждый метод который у нас используется в обработчиках событий нужно будет байндить.


        //! 2) записывать методы через стрелочную ф-ю (использовать синтаксис полей классов).


        //! 3) вызвать событие через анонимную стрелочную ф-ю(коллбек) в самом обработчике. Вызывается анонимная ф-я при клике, она 
        //! внутри себя вызовет  this.nextYear() и за счет того что эта коллбек ф-я стрелочная - this она берет у своего родителя 
        //! в нее попадет ссылка на наш екземпляр класса(объекта)

            <button onClick={ () => this.nextYear() }>{this.state.text}</button>

            //! неудобство что при каждом пересоздании компонента будет создаваться снова эта коллбек ф-я и проблема может быть
            //! если этот колбек дальше передается по props. При изменении props будет заново создаваться тот компонент в который
            //! этот коллбек передается потому что новый коллбек будет отличным от предыдущего, немного теряется оптимизация.

            //! Преимещество - можно передать аргумент в ф-ю. При этом нужно вреяную добавить событие в анонимную ф-ю, а в вызов
            //! ф-и можно добавить аргумент и принять его в методе.

            commitInputChanges = (e, color) => {
                console.log(color)
                this.setState({
                position: e.target.value
                })
            }

            <input type="text" onChange={ (e) => this.commitInputChanges(e, 'some color')} />

   
*/}

{/*    ====    16. Практика состояний на проекте     ====

    Открываем проект. Реализуем при клике на печеньку изменение состояния(state) в этом компоненте. Для этого переделаем компонент
        в классовый и создадим в нем state. Испортируем компонент из реакта, прописываем класс + екстенд компонент, создаем
        конструктор, в нем создаем state со свойством increase, всё что было до этого в компоненте помещаем в метод render
        и добавляем деструктуризацию переменных из this.props чтобы легче обращаться было. Добавим обработчик события и ф-ю
        для него.

        Так как будем изменять состояние в зависимости от того которое было раньше(тоггл) через ! - не(оно инвертирует предыдущее
        на противоположное, так как значение булево и их всего 2, получиться автоматический тогглер), то нужно записать коллбек
        и в нем используем деструктуризацию чтобы сразу вытащить свойство increase из state.

        Теперь значение increase будем брать не из props а из state, поэтому изменим деструктуризацию.

            import { Component } from 'react'
            import './employees-list-item.css';

            class EmployeesListItem extends Component {

                constructor(props) {
                    super(props)
                    this.state = {
                        increase: false
                    }
                }

                onIncrease = () => {
                    this.setState( ({increase}) => ({
                        increase: !increase
                    }))
                }


                render() {
                    const { name, salary } = this.props
                    const { increase } = this.state

                    let classNames = "list-group-item d-flex justify-content-between"
                        if (increase) {
                            classNames += " increase"
                    }

                    return (
                        <li className={classNames}>
                            <span className="list-group-item-label">{name}</span>
                            <input type="text" className="list-group-item-input" defaultValue={salary + "$"} />
                            <div className='d-flex justify-content-center align-items-center'>
                                <button type="button"
                                    className="btn-cookie btn-sm "
                                    onClick={this.onIncrease}>
                                    <i className="fas fa-cookie"></i>
                                </button>

                                <button type="button"
                                    className="btn-trash btn-sm ">
                                    <i className="fas fa-trash"></i>
                                </button>
                                <i className="fas fa-star"></i>
                            </div>
                        </li>
                    )
                }
            }

            export default EmployeesListItem;



    На локальном уровне у нас все работает, но данные глобальные которые в App у нас пока не изменяются.


    //todo Дом. задание. - при клике на span с именем нужно добавлять класс like для этого юзера, тогда будет зажигаться 
    //todo третий значек - звездочка.
    //! Сделано 

    
*/}

{/*    ====    17. Работа с формами, управляемые и неуправляемые компоненты     ====

    Формы в реакт очень похожи на аналоги в стандартной верстке, если не отменять стандартное поведение браузера то они будут
        перезагружать страницу. Отменять его в реакте можно только через event.preventDefault(). Все элементы форм поддерживают
        теже события(только onInput и onChange будут вести себя одинаково).


    
    Практиковаться с формой будем в файле addForm в проекте. Всё что будем вписывать в input должно сохраняться в нашем локальном
        state, поэтому переделаем компонент в классовый. В state будет два свойства - имя новосозданного сотрудника и количество
        денег - зарплата.

            this.state = {
                name: '',
                salary: ''  - //! строка потому что если установить 0 число то к нему добавляются цифры так как ввод строка
            }                  //! происходит конкатенация числа 0 со строкой ЕСЛИ инпут контролируемый

        Навесим обработчик события на оба инпута. И сделаем одну ф-ю для обоих обработчиков, смысл которой будет в том чтобы брать
        e.target.value и изменять необходимое свойство в state, это можно сделать с помощью ES6 синтаксиса. Так как мы не привязаны
        к тому что у нас хранится в свойстве до этого то делаем без коллбека. Сложность состоит в том как записать значение в нужное
        свойство. Для этого к инпутам добавим аттрибут name в котором будем указывать названия идентичные с названиями свойства в
        state, потом будем их брать и подставлять вместо названия изменяемого свойства как переменную, //! нужно обязательно брать в
        //! квадратные скобки чтобы не было ошибки.

            onValueChange = (e) => {
                this.setState({
                    [e.target.name]: e.target.value
                })
            }
        
            <input type="text"
                className="form-control new-post-label"
                placeholder="Как его зовут?"
                name='name'
                onChange={this.onValueChange} />
            <input type="number"
                className="form-control new-post-label"
                placeholder="З/П в $?"
                name='salary'
                onChange={this.onValueChange} />


        Эти инпуты у нас не управляемые(контролируемые) потому что значение вноситься только из инпута прямо в state но обратной
        связи нету. 
        
    
    
    Если нужно чтобы реакт компонент рендерил форму и контролировал её поведение в ответ на пользовательский ввод то нужно 
        добавить value = {} и в него помещать значение state. Такие элементы называются управляемыми.

            render() {
            const { name, salary } = this.state

            return (
                <div className="app-add-form">
                    <h3>Добавьте нового сотрудника</h3>
                    <form
                        className="add-form d-flex">
                        <input type="text"
                            className="form-control new-post-label"
                            placeholder="Как его зовут?"
                            name='name'
                            value={name}
                            onChange={this.onValueChange} />
                        <input type="number"
                            className="form-control new-post-label"
                            placeholder="З/П в $?"
                            name='salary'
                            value={salary}
                            onChange={this.onValueChange} />


        //! Зачем это делается - для синхронизации state с интерфейсом UI. Тоесть при вводе в инпут запускается setState который
        //! заново запустит render и при рендере значение будет браться не из поля, а из state. Это дает нам то что на все изменения
        //! интерфейс будет реагировать мгновенно, особенно это полезно при валидации данных, когда до момента записи в state данные
        //! проходят проверку на правильность и только тогда записываются в state. В основном используются именно такие контролируемые
        //! компоненты/елементы.

        //! Также существуют неуправляемые компоненты, значение которых храняться прямо в ДОМ дереве - тоесть в самом юзер интерфейсе,
        //! и это плохо потому что теряется возможность правильного использования инпутов и форм.

        //! Единственный инпут который в реакте всегда будет не управляемым - type='file' - позволяет юзеру загружать в него файл.
        //! так как файл в value отправить не можем))

        //todo есть приложенная статья на английском, но в конце там есть выводы можно почитать.
    
    
*/}

{/*    ====    18. Иммутабельность состояния, собственные события     ====

    Будем удалять сотрудников при нажимании на кнопку корзины. В реальном приложении когда сотрудник удалится со страницы он
        должен удалиться и на сервере(в базе данных). Чтобы удалился сотрудник нам нужно удалить его из данных. Сейчас иконка
        корзины находится в компоненте EmployeesListItem который не связан с данными которые лежат в App и чтобы связать их
        и отслеживать действия с ними нам нужно написать свои собственные события. Тогда если кликнем на корзинку на сотруднике
        он удалиться из данных они прийдут в компонент в котором рендерятся сотрудники, реакт увидит разницу и перерисует
        часть компонента которая изменилась.



    Откроем EmployeesList. Помним что как props мы можем передавать все что угодно, в том числе и ф-и. Передадим ф-ю в
        EmployeesListItem, она будет выводить в консоль сообщение - Deleted.

            return <EmployeesListItem 
                        key={id} 
                        { ...itemProps }
                        onDelete={() => console.log('Deleted')} />


        теперь можно ее использовать в компоненте EmployeesListItem, применим ее в компоненте на обработчик события,
        предварительно вытащив ее из props.

            const { name, salary, onDelete } = this.props

            <button type="button"
                className="btn-trash btn-sm "
                onClick={onDelete}>

            таким образом мы связали два компонента находящихся на разных уровнях иерархии - корневого и дочернего.


        Раз это работает с двумя элементами то передадим ф-ю из App в EmployeesList. Стрелочная ф-я которая будет
        получать какой то id и выводить его в консоль.

            <EmployeesList data={data} onDelete={id => console.log(id)}/>


        Теперь в EmployeesList будем использовать эту ф-ю предварительно достав ее из props и подставив вместо
        консольлога. И так как ф-я принимает один аргумент, то нужно ее вызвать с каким то аргументом. Тут мы
        как раз получали уникальный id для идентификации сотрудника(чтобы занести его в key), его и будем
        использовать.
        
            const EmployeesList = ({data, onDelete}) => {

            const elements = data.map( item => {
                const {id, ...itemProps} = item
                return <EmployeesListItem 
                        key={id} 
                        { ...itemProps }
                        onDelete={() => onDelete(id)} />

            теперь когда кликаем по корзине в консоль выводиться номер id сотрудника.


        Всё это произошло благодаря приему - передачи проперти(передачи свойств компонентов по иерархии) по научному это
        называется property drill - который рассмотрим позже. С самого верхнего компонента мы обозначили(написали) ф-ю
        передали дальше в компонент, там его вызвали с id(потому что тут есть id, а если вызвать в компоненте ниже то
        будет ошибка) и передали еще ниже и там она будет вызываться от клика юзера по кнопке. Таким образом можно
        передавать вниз и данные и методы и всё что угодно.

    

    На базе этого ф-ла приступим к удалению из массива данных data в App компоненте. Для динамической работы с 
        данными в реакте нам нужен state, в который и поместим эти данные. Переделываем App в классовый. data
        в нижний компонент теперь передаем из this.state.data. Ф-ю которую передавали теперь сделаем отдельным
        методом чтобы не писать код прямо при передаче, и чтобы иметь возможность его переиспользовать назовем
        его deleteItem. Теперь можно вместо консольлога работать с setState, сразу вытащим data из объекта
        state, но сразу возвращать объект не будем поэтому () эти скобки не ставим, а раскрывает фигурные
        скобки(тело ф-и) и будем выполнять в них определенные действия.

            class App extends Component {
            constructor(props) {
                super(props)
                this.state = {
                data: [
                    { name: "John C.", salary: 800, increase: true, id: 1 },
                    { name: "Alex M.", salary: 300, increase: true, id: 2 },
                    { name: "Carl W.", salary: 5000, increase: false, id: 3 }
                ]
                }
            }

            deleteItem = (id) => {
                this.setState(({data}) => {
                
                })
            }

            render() {
                return (
                <div className="app">
                    <AppInfo />

                    <div className="search-panel">
                    <SearchPanel />
                    <AppFilter />
                    </div>

                    <EmployeesList data={this.state.data} onDelete={this.deleteItem} />


        
        Алгоритм действий при удалении элемента из массива с объектами. Ориентироваться будем на id с которым
        этот метод вызывается. Теперь берем этот id и находим нужный объект внутри массива что бы его потом удалить.
        А потом будем изменять state чтобы созать новое состояние и запустить перерисовку компонента. id мы уже получили
        теперь рассмотрим как будем искать нужный объект. Это можно делать двумя способами:


        1) Находим индекс объекта в массиве по id через findIndex который вернет номер индекса объетка в котором нашел совпадения
        id, поместим его в переменную index и используем для удаления. 

            deleteItem = (id) => {
                this.setState(({data}) => {
                const index = data.findIndex(elem => elem.id === id)
                console.log(index)
                })
            }
        
            в консоль выводиться индекс елемента в массиве.

        теперь нужно удалить объект сохраняя иммутабельность state, тоесть state после создания не должен меняться и чтобы
        внести изменения создаем копию state вносим изменения в нее и присвоим эту копию как новый объект в state. Таким
        образом можно лего проследить что изменилось сравнивая новый и старый объект и это хорошо ложиться в концепцию
        реконцеляции(алгоритмов сравнения), также тестирование таких изменений будет легче. При таком подходе будет чуть
        больше расход памяти из-за создания множества объектов, но с характеристиками текущих гаджетов это не проблема.
        //todo приложена уникальная статья про иммутабельность в JS с примерами.

        //! Посмотрим как делать не нужно изменяя на прямую data в state. Методом splice просто удаляем елемент с полученым
        индексом, и вернем измененный объект чтобы setState его использовал. 
            
            deleteItem = (id) => {
                this.setState(({data}) => {
                const index = data.findIndex(elem => elem.id === id)
                data.splice(index, 1)
                return {
                    data: data
                }
                })
            }

            При нажатии на корзину сразу два сотрудника удаляются.
                
        Теперь как сделать правильно с использованием индекса - нужно создать новый массив который будет содержать все елементы
        старого массива но без того который удалим. Используем метод slice он копирует часть массива и создает новый. Скопируем
        часть до удаляемого элемента и после удаленного и склеим их в один массив. Первая переменная before будет копировать
        массив с начала(0 индекс) до полученого index, вторая переменная after будет копировать массив с index до конца.
        Потом их распакуем в новый массив и его вернем для присвоения data.

            deleteItem = (id) => {
                this.setState(({data}) => {
                const index = data.findIndex(elem => elem.id === id)

                const befor = data.slice(0, index)
                const after = data.slice(index + 1)

                const newArr = [ ...befor, ...after]

                return {
                    data: newArr
                }
                })
            }

        Такой метод не очень удобен потому что нужно 3 действия производить. Поэтому будем использовать метод 2.



        2) Для этого метода используем метод filter который создает новый массив со всеми елементами прошедшими проверку
        и будет сравнивать объекты по id, поэтому не нужно вычислять индекс. 

            deleteItem = (id) => {
                this.setState(({data}) => {
                    return {
                    data: data.filter(item => item.id !== id)
                    }
                })
            }

        данные отфильтруются и остануться только те елементы id которых не совпадает с полученным id.



    //todo домашнее задание - сделать добавление нового сотрудника чтобы он также появлялся в state. В новом объекте
    //todo будет полу id поэтому при создании новго объекта его нужно сгенерировать. Самый простой способ для этого
    //todo сделать новой свойство в конструкторе this.maxId = 4 и когда добавляем нового сотрудника брать из него
    //todo значение и увеличивать на единицу. Вариант сложнее - написать ф-ю по генерации случайного уникального id
    //todo или взять готовый пакет как например react-id-generator. Для отправки формы использовать событие
    //todo onSubmit
    //! Сделано.

   
*/}

{/*    ====    19. Практика. Подъем состояния     ====

    Сделаем чтобы в шапке подсчитывалось общее кол. сотрудников и Премию полчуча. Сложность тут состоит в том что
        app-info в котором это должно подсчитываться по структуре проекта лежит не там где у нас сотрудники и не там
        где мы можем отмечать их печеньками, но для подсчета ему нужно знать эти данные. Данные про сотрудников
        можно взять из state App, но данные про повышенных сотрудников у нас пока храняться в EmployeesListItem
        и не передаются в App. Тоесть нужно из EmployeesListItem передавать значения свойств в App а потом из
        state App будем брать всю информацию для app-info. Такой прием когда локал state одного компонента поднимаем
        выше по иерархии называется - подъемом состояния(state lifting).


    
    Сделаем новые методы в App. 

        onToggleIncrease - для замены того который меняет increase в EmployeesListItem, теперь будем прокидывать
        этот метод чтобы использовать в компоненте и изменять increase для state в App.

        onToggleRise - этот метод который используется при клике на имя сотрудника - идет на повышение - звездочка
        показывается. Вместо - onLike.

        В оба метода принимаем id нужного сотрудника. Пока что сделаем консольлоги в середине методов и пробросим
        их в компонент чтобы удостовериться что они отрабатывают.

            onToggleIncrease = (id) => {
                console.log(`Increase ${id}`)
            }

            <EmployeesList 
                data={this.state.data} 
                onDelete={this.deleteItem}
                onToggleIncrease={this.onToggleIncrease}


        в employees-list вытаскиваем их и прокидываем дальше с запуском коллбеком и передачей id в ф-и.

            return <EmployeesListItem 
                key={id} 
                { ...itemProps }
                onDelete={() => onDelete(id)}
                onToggleIncrease={() => onToggleIncrease(id)}
                onToggleRise={() => onToggleRise(id)} />


        Вытаскиваем их в EmployeesListItem и заменяем те которые были. Теперь нам не нужны локальные методы
        и локальный state в этом компоненте, потому что состояние будет контролироваться из App. И так как
        state локальный уже не нужен можно обратно переделать этот компонент в ф-й. Добавим increasу и rise
        в props которые приходят из App и в App добавим свойство rise в state, также добавим новое свойство
        в объект который добавляется в state.


        Теперь наполним внутренности новых методов. Алгоритм такой, вытаскиваем объект с которым работает 
        юзер по id, копируем его изменяем нужное свойство создать новый state(и поменять его уже в 
        компоненте). Рассмотрим два метода как это можно сделать.

        1) Снова сложный метод через нахождение индекса объекта. В setState вытягиваем data, потом находим
        индекс елемента, присваеваем часть data - объект по найденому индексу в old - эта переменная нужна
        для того чтобы брать старое значение изменяемого свойства. Потом копируем этот объект через
        деструктуризацию в объект который присвоим newItem(при этом он разворачивается на свойства) и через
        запятую к развернувшимся свойствам добавляем новое свойство со значением которое будет противоположно
        этому же значению из old - куска оригинального объекта(тут мы только считываем значение, и не меняем
        его) при этом если свойство с таким именем уже есть в объекте старое просто замениться на новое.
        В newArr создаем новый массив в который деструктуризируем(копируем и разворачиваем) начало data до 
        объекта с нужным индексом, сюда же добавляем новый измененный объект и дальше деструктуризируем
        оставшуюсья часть массива data, при индексе 1 например слайс можно представить в таком виде 
        - slice(index + 1) = slice(1+1) = slice(2) - итого эта ф-я вернет все объекты начиная со второго
        индекса включительно.

            onToggleIncrease = (id) => {
                this.setState(({data}) => {
                const index = data.findIndex(elem => elem.id === id)

                const old = data[index]
                const newItem = { ...old, increase: !old.increase}
                const newArr = [ ...data.slice(0, index), newItem, ...data.slice(index + 1)]

                return {
                    data: newArr
                }
                })
            }


        2) Этот способ аналогичен способу при удалении через фильтр, только тут мы используем
        map чтобы пройтись по всем элементам и найти нуйжный по id. Из setState сразу будем возвращать сразу новый 
        объект, поэтому будут дополнительные скобки. У него будет свойство data значением которого будет формироваться
        новый массив. Применение на data - map возвращает новый массив, при этом нужно прописывать return в конце в теле
        map. map проверяет каждый объект - и значит можно применить условие if, при нахождении нужного объекта мы 
        возвратим новый объект вместо старого с измененным свойством rise, return на этой итерации нужно потому что нужно
        каждый item возвращать, а при срабатывании условия ф-я заходит в if и потом не сработает общий return, значит его
        нужно дописать в if.


            onToggleRise = (id) => {
                this.setState(({ data }) => ({
                data: data.map(item => {
                    if (item.id === id) {
                    return { ...item, rise: !item.rise }
                    }
                    return item
                })
                }))
            }

        Работает, изменения можно отслеживать через установленное расширение вкладка components - смотрим на state, видим что есть
        некоторая задержка между нажатием на кнопку и изменением state - это потому что ф-я асинхронная. Если быстро понажимать
        на кнопку видим что state не меняется на каждый клик, а видим редкое переключение state с промежуточными, а потом и с 
        конечным результатом - так происходит потому что несколько вызовов setState объединяются в один.



    Теперь можно реализовывать счетчики в хедере. 
    //! Сначала попробовать самим подсчет делать в App а результаты передаватьчерез props в компонент app-info.

        Мое решение:  сначала попробовал сделать как константы там где прописаны методы - подсвечивало ошибку и не работало, 
        потом сделал как методы(ф-и) работало но не обновлялся в самом App-info компоненте, пришлось сделать как вызов ф-и.

               this.maxId = 4
            }

            totalEmloyee = () =>  this.state.data.length
            emloyeeRise = () => (this.state.data.filter(elem => elem.rise !== false)).length
            
            deleteItem = (id) => {


            <AppInfo totalEmloyee={this.totalEmloyee}
                  emloyeeRise={this.emloyeeRise}/>


            App-info
            <h2>Общее число сотрудников: {props.totalEmloyee()}</h2>


        Нормальное решение: константы делаются в методе рендер, так как рендер будет запускаться каждый раз при изменении state
        то они будут заново высчитываться и не нужно будет запускать их в компоненте App-info, а просто в него передавать уже
        вычисленные данные.

            render() {

                const totalEmloyee = () =>  this.state.data.length
                const emloyeeOnRise = () => this.state.data.filter(elem => elem.rise ).length  -//! возвращаем те елементы у которых
                                                                                                //! elem.rise  - true
                return (
                <div className="app">
                    <AppInfo totalEmloyee={totalEmloyee}
                            emloyeeRise={emloyeeOnRise}/>

            App-info
            const AppInfo = ({totalEmloyee, emloyeeOnRise}) => {
                return (
                    <div className="app-info">
                        <h1>Учет сотрудников в компании N</h1>
                        <h2>Общее число сотрудников: {totalEmloyee}</h2>


        //! Почему то была ошибка - Functions are not valid as a React child. Пришлось делать вызов для ф-й которые показывают
        //! количество сотрудников и на повышение. <h2>Общее число сотрудников: {totalEmloyee()}</h2>
        //! Наверное потому что эта ф-я нигде не вызывается, тоесть не рендерится как компонент и не незначена на событие.???
        //! Все решения в инете советуют или вызывать ф-ю или если это компонент указывать как компонент {< TotalEmloyee />}
        //! но для этого он должен быть настоящим компонентом(наверное ???)


    //! Так как автор сделал оба метода через map то видно что отличие в них только в названии свойства вместо 
        return { ...item, increase: !item.increase }  будет return { ...item, rise: !item.rise }. Если есть время и сроки проекта
        не горят то можно произвести оптимизацию(рефакторинг) чтобы исключить дублирование кода.

        Удалим старые методы и оставим один onToggleProp, в который будем передавать вторым аргументом prop - название того 
        свойства которое будет использоваться. //! Используем квадратные скобки чтобы не было ошибок. И передадим в компонент
        только один метод.

            onToggleProp = (id, prop) => {
                this.setState(({ data }) => ({
                data: data.map(item => {
                    if (item.id === id) {
                    return { ...item, [prop]: !item[prop] }
                    }
                    return item
                })
                }))
            }

            <EmployeesList
                data={this.state.data}
                onDelete={this.deleteItem}
                onToggleProp={this.onToggleProp} />


        В EmployeesList достаем из props этот метод, прокидываем дальше удаляя старые. //!Так как он вызывается тут то второй 
        //! аргумент тоже будем получать тоже тут, это должна быть строка и она должна быть получена с того элемента на котором
        //! происходит событие клика, поэтому присвоим в EmployeesListItem дата аттрибуты елементам, потому что это метки которые
        //! легко получить и это один из вариантов который можно применить к любому HTML элементу, в реакте они пишутся через 
        //! дефис как исключения. Присвоим data-toggle = "rise" и increase  и будем получать их значениея из события - е которое 
        //! приходит АВТОМАТИЧЕСКИ если ф-я предается как просто как ссылка на нее, а не как вызов со скобками. Из события по 
        //! currentTarget получаем значение аттрибута data-toggle. Используем currentTarget вместо обычного target чтобы игнорировать
        //! всплытие событий и получить именно тот елемент на котором произошел клик.

            return <EmployeesListItem 
                key={id} 
                { ...itemProps }
                onDelete={() => onDelete(id)}
                onToggleProp={ (e) => onToggleProp(id, e.currentTarget.getAttribute('data-toggle') ) } />


        EmployeesListItem

            return (
            <li className={classNames}>
                <span className="list-group-item-label" 
                      onClick={onToggleProp}
                      data-toggle = "rise">{name}</span>
                <input type="text" className="list-group-item-input" defaultValue={salary + "$"} />
                <div className='d-flex justify-content-center align-items-center'>
                    <button type="button"
                        className="btn-cookie btn-sm "
                        onClick={onToggleProp}
                        data-toggle = "increase">
                        <i className="fas fa-cookie"></i>
                    </button>



    //todo Домашнее задание - сделать так чтобы нельзя было добавлять пустых сотрудников. Чтобы имя было не меньше 3 символов
    //todo и чтобы были цифры в зарплате, способов тут много, на свое усмотрение.
    //! Сделано.

    
*/}

{/*    ====    20. Реакт фрагменты     ====

    Рассмотрим на тестовом примере. 

    Ранее учили что нужно всегда JSX код(структуру) оборачивать в один родительский елемент div. Но он ломает верстку там где
        используются grid, flex или 100% какой то ширины, и зачастую используют Fragment для обхода этой проблемы создали , 
        он лежыт в реакте и его можно выташить как и Component, существует 2 способа их применения:

        1) Импортуруем Fragment и теперь можно его использовать для замены div.

            import { Component, Fragment } from react;

            render() {
                const { name, surname, link } = this.props
                const {position, years} = this.state
                return (
                <Fragment>
                    ...
                </Fragment >

            теперь смотрим на DOM дерево и видим что их нету, в app в верстке идет набор всех елементов которые были внутри.


        2) При этом способе Fragment не импортируем. А вместо <div></div> - оставляем пустые скобки <></> это сокращенная
        запись, при которой реакт сам поймет что используется фрагмент


        //! Чаще всего div не используют, а используют синтаксис с пустыми скобками фрагмента, но там где мы делаем map
        //! для того чтобы незначить key такой синтаксис не пройдет,  нужно будет прописывать <React.Fragment key='223'
   
    
*/}

{/*    ====    21. Практика. Реализуем поиск и фильтры     ====

    Реализуем поиск и фильтры на проекте. 

    Начнем с поиска. Логика такая - юзер вводит в поле значение, так как будет контролируемый инпут то мы его сохраняем в локальном
        state(для этого переделаем компонент в классовый), эту же строку передадим через ф-ю из App в state общий в котором создадим 
        свойство с тем же названием как и в локальном и будем принимать его значение в качестве фильтра для новjuj отфильтрованного
        массива показываемого вместо обычного. Сделаем условие что если строка поиска пустая то массив из state ее будем фильровать
        таким образом отфильтрованный массив будет таким же как в state. Сначала реализуем поиск - если эта буква или комбинация букв
        есть в строке name объекта(а не по первой букве). У нас будет два метода в App(один изменяет state второй фильтрует фильтрует
        он будет получать строку по которой  фильтруем, а третий в компоненте app-filter он будет срабатывать при onChange записывать 
        строку в локальный state и запускать ф-ю которая прийдет из App передавая строку туда.


        Создаем новое свойство в state, вытащим его из state в rendere. Теперь напишем метод для поиcка через фильтр, принимать он
        будет массив в котором нужно искать соответствия и строку которую нужно искать. Пропишем условие на пустую строку - чтобы
        возвращался тот массив который был передан, если нет тогда будем возвращать отфильтрованный массив. Искать будем любое
        совпадение строки в свойстве объекта name через метод indexOf. Если он не находит совпадений то возвращает -1, если находит
        то возвращает индекс с которого найдено вхождение, может быть 0 поэтому делаем проверку того что он будет больше -1, 
        если да то этот элемент возвращается(помещается) в новый массив. Теперь нужно показать этот отфильтрованный массив,
        пока у нас отображается массив data, и поэтому нужно к нему применить наш метод чтобы отображался всегда отфильтрованный 
        массив. Для такого действия сделаем новую константу visibleData и будем отображать ее вместо data. Для установления term
        нового значения из инпута создадим метод onUpdateSearch он будет сетать в state строку которую методу передадут при 
        вызове его в компоненте при onChange. Этот метод нужно передать в компонент SearchPanel.

                        { name: "Carl W.", salary: 5000, increase: false, id: 3, rise: false }
                        ],
                    term: ''
                }
                this.maxId = 4
            }   


            searchEmployee = (items, term) => {
                if(term.length === 0) {
                return items
                }

                return items.filter(item => {
                return item.name.indexOf(term) > -1
                })
            }

            onUpdateSearch = (term) => {
                this.setState({term: term})  //!  this.setState({term}) - идентичные записи когда название полей совпадают
            }

            render() {
                const { data, term } = this.state
                const totalEmloyee = () => this.state.data.length
                const emloyeeOnRise = () => this.state.data.filter(elem => elem.rise).length
                const visibleData = this.searchEmployee(data, term)

                return (
                <div className="app">
                    <AppInfo totalEmloyee={totalEmloyee}
                    emloyeeRise={emloyeeOnRise} />

                    <div className="search-panel">
                    <SearchPanel onUpdateSearch={this.onUpdateSearch} />

            Пока больше кода не написали, можно протестировать работоспособность этого кода изменяя физически строку term в state.


        Работаем в компоненте SearchPanel. Переделаем его в классовый, сделаем state со свойством term и сделаем метод с таким же
        названием - onUpdateSearch(он будет сохранять строку в локал state и запускать переданную ф-ю onUpdateSearch из App
        с передачей в нее строчки из инпута) при запуске его по событию onChange. Сделаем значение инпута управляемым.

            import { Component } from 'react'

            class SearchPanel extends Component {
                constructor(props) {
                    super(props)
                    this.state = {
                        term: ''
                    }
                }

                onUpdateSearch = (e) => {
                    const term = e.target.value
                    this.setState({ term })
                    this.props.onUpdateSearch(term)
                }

                render() {
                    return (
                        <input type="text"
                            className="form-control search-input"
                            placeholder="Найти сотрудника"
                            value={this.state.term}
                            onChange={this.onUpdateSearch} />
                    )
                }
            }



    Остались фильтры.
    //todo попробовать сделать самостоятельно

        14-00




















    

    
*/}

{/*    ====    22. Семантика и доступность контента     ====













    

    
*/}

{/*    ====    23. Стили в React. Inline Styles     ====
 

    
*/}

{/*    ====    24. Стили в React. CSS и SASS/SCSS     ====
 

    
*/}

{/*    ====    25. Стили в React. Динамические классы и стили     ====
 

    
*/}

{/*    ====    26. Стили в React. Styled Components     ====
 

    
*/}

{/*    ====    27. Стили в React. Готовые библиотеки со стилями     ====
 

    
*/}

{/*    ====    28. Поля классов и static     ====
 

    
*/}

{/*    ====    29. Заключение модуля     ====
 

    
*/}



//==============================================  СРЕДНИЙ ФУНДАМЕНТАЛЬНЫЙ УРОВЕНЬ ==============================================\\

{/*    ====    01. Что такое API и как работают реальные приложения     ====
 
*/}

{/*    ====    02. Новый проект и работа с сервером     ====
 
*/}

{/*    ====    03. Трансформация данных и компонент со случайным персонажем     ====
 
*/}

{/*    ====    04. Хороший тон приложения (спиннер, ошибки...)     ====
 
*/}

{/*    ====    05. Жизненный цикл компонентов     ====
 
*/}

{/*    ====    06.  Практика с жизненным циклом, componentDidUpdate     ====
 
*/}

{/*    ====    07. Предохранители (Error Boundaries)     ====
 
*/}

{/*    ====    08. Пагинация данных (дозагрузка персонажей)     ====
 
*/}

{/*    ====    09. Проверка типов с помощью PropTypes     ====
 
*/}

{/*    ====    10. Вставка элементов через props.children     ====
 
*/}

{/*    ====    11. Специализация и наследование     ====
 
*/}

{/*    ====    12. Render-props паттерн     ====
 
*/}

{/*    ====    13. Что такое ref и зачем он нужен     ====
 
*/}

{/*    ====    14. Порталы     ====
 
*/}

{/*    ====    15. “Бандлинг” и выгрузка проекта на сервер     ====
 
*/}