//==============================================  БАЗОВЫЙ УРОВЕНЬ ==============================================\\

{/*    ====    02. Что такое реакт     ====

    React нужен для оптимизации (в основном для веб приложений - обычные программы в браузере) и ускорения разработки.
        Стандартизация инструментов на рабочем месте для разных разработчиков.

    
*/}

{/*    ====    03. Принципы реакта (SPA)     ====

    Реакт - библиотека на основе JS, разработана facebook для упрощения разработки юзер интерфейсов. С помощью реакта можно
        создавать одностраничные приложения - SPA(single page application), изменяют страницу без перезагрузки, происходит 
        контроль использования памяти приложения.



    Принципы(плюсы) реакт:

        - Декларативный(говорит какой результат нам нужен) - создаем юзер интерфйсы в разных состояниях, а  обновлением состояний
            занимается реакт.

        - Основан на компонентах(повторяющиеся блоки) - компактные и независимые от другого кода для переиспользования где угодно и
            легкого тестирования

        - Реакт может работать на сервере(Node.js) и на мобильныз платформах(React Native)


        - Использует препроцессор JSX (удобное представление разметки в JS коде, писать js код можно прямо в ней)

        - Алгоритм сравнения(реконселейшн) - отслеживает какие части изменились и обновляет только их.

        - Virtual DOM
    

*/}

{/*    ====    04. Create React App (CRA)     ====

    CRA - настроенная сборка которая создается по вводу 1 строки кода в консоли среды разработки  -  npx create-react-app my-app
        
    cd my-app - зайти в папку с проектом

    npm start - запустить проект ( в режиме разработки)



    В nodemodules - все модули нужные для работы сборки. Основные - webpack - собирает проект, поддерживает хот релоад сервера, и
        Babel - компилирует JSX разметку, следит за поддержкой браузеров.

    Если включен плагин JShint нужно его отключить потому что он будет конфликтовать с подключенным по умолчанию в проекте
        ES lint и также он не понимает JSX будет подсвечивать ошибки.


    После запуска приложения в консоли браузера видим сообщение которое предлагает установить расширения для удобного дебаггинга,
        устанавливаем

    
*/}

{/*    ====    05. JSX, его ограничения     ====

    index.js - основной файл в котором ренедериться компонент с нашим приложением App.js. Если писать код в index то бывает
        что не происходит автоматическое обновление.

        //! Код в index может отличаться в зависимости от различных версий React 

    

    Первое что видим в файле это импорты. Если не указан путь то импортируется из папки node_modules. 

        Сначала импортируется React из модуля react - отвечает за работу реакта с JSX и внутренними возможностями.

        ReactDOM - позволяет работать с DOM структутрой на странице(вставлять реакт и приложение на страницу)

        import App from "./App" - компонент с приложением

        web Vitals - измеряет производительность приложения, можно удалить


    //! Март 22 вышел реакт 18. Теперь немного изменился index. ReactDOM теперь импортируется из 'react-dom/client' это спец. раздел
        который относится к клиентской части реакта, также изменился порядок команд, но принцип остался тот же. Если в index не 
        изменить код то просто не будут работать новые фишки 18 реакта и он будет работать как на предыдущей версии.

        Документация на английском актуальна для последнего обновления, рус версия может не успевать за ней.

        В курсе показан синтаксис 17 реакта.


        У ReactDOM вызывается метод render и передаются 2 аргумента, 1й - что - приложение которое рендериться, 2й - куда.
        //! Этот render должен вызываться только раз на самом верхнем уровне приложения( index ), бывают исключения. 
        Все остальное приложение собираем по отдельным файлам и заключаем в такую ф-ю как - App, его мы и будем предоставлять
        странице чтобы она нам его показала.



    //! В реакте до 17й версии для работы Babel нужно было импортировать React в каждый файл где есть jsx, после 17й версии 
        переписали код и теперь этого делать не нужно, импортируем только в index.js. При работе со старыми проектами если
        удалить импорты без апгрейда до новой версии реакта сломается проект.



    Реакт елемент - елемент интерфейса
        
            const elem = <h2>Hello</h2> 

        //! Если елемент большой(многострочный) нужно его оборачивать в скобки и у него всегда должен быть 1 родитель(обертка div)
        это связанно со способом создания элемента (создается один простой елемент а остальные елементы помещаются внутрь него как
        текст)  

            const elem = (
                <div>
                    <h2>Hello</h2>
                    <input type="text" />
                    <button />
                </div>
            ) 



    //! Чтобы в jsx работал emmet для создания тегов через таб нужно его донастроить(по умолчанию он не знает что в js файле можно
        вставлять верстку). Открываем настройки юзера - ctrl+, - сверху написано user, выбираем extensions -> emmet -> 
        include language -> add item  -> key - javascript, value - javascriptreact



    //! Главные правила елементов:
        - использовать скобки для многостроных элементов
        - один родитель для многострочного элемента
        - не забывать закрывать тег



    JSX позволяет вставлять внутрь себя код как при использования строки с обратными кавычками(бектиками) но без доллара

            <h2>Text: {text}</h2>

            return  <button>{ logged ? "Enter" : text }</button> - использование логического условия(//! тернарный оператор, if 
                                                                   не работает внутри таких фигурных скобках в елементах)

        //! можно вставлять текст, мат операции,  свойства объектов, вызов ф-й/методов, КРОМЕ ОБЪЕКТОВ, тоесть нельзя поместить
        //! <h2>{new Date()}</h2> - будет ошибка, так сделано для безопасности кода, чтобы нельзя было помещать сторонние скрипты.
        //! В реакте все значения экранируются и переводяться встроки и когда запустится команда которая вернет объект то при 
        //! переводе будет просто 'object object'. С массивом будет работать но все елементы сконкатенируются.
        //! Правило именно для показа на на странице, передавать в props объекты можно, но перед показом на странице нужно из
        //! объекта вытащить содержимое.

          
        
    Аттрибуты css можно использовать с особенностями:
    
        - всегда пишуться в камел кейс если состоит более чем из 1 слова (исключения aria- , data-  -> aria-label)

                background-color  -> backgroundColor

                tabindex -> tabIndex

                <button tabIndex="0" >Click</button>


        - некоторые аттрибуты пишуться по своему в реакте потому что эти слова зарезервированы в JS

                class   ->  className

                for     ->  htmlFor

    
*/}

{/*    ====    06. Элементы и компоненты     ====

    Одна из основных концепций реакта - разбиение приложения на компоненты - функции которые могут возвращать JSX элементы,
        блоки юзер интерфейса которые могут иметь собственное поведение. Они могут переиспользоваться в разных местах кода и 
        состоят из элементов. 
        
        //! элементы в реакте неизменяемые, нельзя просто обратится к нему через класслист и добавить или
        удалить класс, назначить аттрибут. //! Чтобы изменить элемент нужно его полностью перерисовать на странице. В коде проводим
        операции что то изменяем, потом элемент проходит через виртуал дом и потом отрисовывается на странице взамен старого но уже
        с новыми параметрами. Можно в частных случаях напрямую обратиться к ДОМ элементу, но это используется очень редко.



    КОМПОНЕНТЫ правила:
        - всегда пишутся с большой буквы  <App/>
        - всегда есть return - чтоб возвращать JSX
        - если компонент слишком большой или его часть может использоваться в другой части кода, обладает логикой, нужно 
            выделить в отдельный компонент


        Чтобы использовать компонент в другом файле его нужно експортировать или по дефолту - тогда в другом файле можно при
        импорте назвать его по другому или именновано, тогда при импорте нужно указать именно то имя с которым файл експортировался.

        файл App
            export {Header};        или  добавляем перед самим елементом(ф-й) export function Btn() {...
            export default App;

        Файл индекс
            import { Header } from './App';
            import App from './App';        или  import MyApp from './App';



    Можно создавать через скобки как внутренности елементов, так и свойства тегов. //! В style вставлен созданный объект.
            const Field = () => {
                const holder = "Enter here"
                const styledField = {
                    width: '300px'
                }
                return <input placeholder={holder} type="text" style={styledField}/>
            }
        


    Классы в JS это теже ф-ии просто обернути в оболочку. Тоесть ф-и могут быть классами

            const Field = () => {
                const holder = "Enter here"
                const styledField = {
                    width: '300px'
                }
                return <input 
                        placeholder={holder} 
                        type="text" 
                        style={styledField}/>
            }

        перепишем как класс - для того чтобы они работали как задумано в реакте, нужно чтобы создаваемый класс унаследовал 
        поведение от родительского класса реакта. Для этого в файл импортируем реакт а потом из него достанем компонент с классом,
        если не нужно ничего конструировать то constructor не прописываем, но вклассовом компоненте должен быть как минимум 1 метод
        который будет что-то создавать (возвращать JSX) - render()
            
            import React from react;  -> const Field extends React.Component {

                или можно сразу вытащить компонент и не прописывать реакт каждый раз при создании классового компонента

            import {Component} from react;  -> const Field extends Component {

            const Field extends React.Component {
                render() {
                    const holder = "Enter here"
                    const styledField = {
                    width: '300px'
                    }
                    return <input 
                            placeholder={holder} 
                            type="text" 
                            style={styledField}/>
                }
            }
    

*/}

{/*    ====    07. Строгий режим     ====

    По функционалу он похож на strict mode в JS. Можно вытаскивать объекты реакта через запятую

            import React, {StrictMode, Component} from 'react';

            <StrictMode>
                <App />
            </StrictMode>


        Простым языком это компонент для обнаружения потенциальных проблем в приложении. Он ничего не рендерит и не заменяется 
        никаким другим компонентом, а существует внутри реакта - он активирует дополнительные проверки и предупреждения для потомков
        (вложенных в него компонентов), тоесть этот компонент можно использовать где угодно в приложении. Он помогает обнаруживать
        устаревшие и небезопасные конструкции и сообщает о некторых побочных эффектах. Эта возможность будет работать только в 
        режиме разработки.

        Это полезно в случаях: 
            - копирования чужого(устаревшего) кода 
            - когда нужно перевести приложение со старой версии реакта на новую, тогда можно быстро обнаружить те участки кода
                которые следует исправить перед переходом.

        Сообщения будут показываться в консоли браузера и в терминале.

    
*/}

{/*    ====    09. Создание нового проекта (практика)     ====

    Приложение учета сотрудников. Можно будет добавлять/удалять сотрудников, отмечать их, делать фильтраци(по размеру ЗП, 
        На повышение(чекбокс), имени - инпут). Это приложение показывает основные момента при работе с веб технологией 
        CRUD - Create Read Update Delete. Приложение - разновидность TODO - приложений которые часто дают на собеседованиях
        чтобы увидеть человек работает с этими базовыми концепциями. Заморачиваться стилями для приложения не будем - воспользуемся
        готовым набором классов которые будем подключать через CDN сервер (cdnjs.com).

        В этом уроке будем создавать структурную оболочку приложения - версткой разбитой на правильные компоненты и использующей
        правильные елементы по всем правилам из предыдущих уроков. Можно скачать по ссылке проект с готовой версткой и установить
        необходимые модули через npm i.
 


    Подключим бутстрап для задания готовых стилей через cdnjs.com - заходим на сайт, вбиваем bootstrap заходим в него и копируем
        в index ссылку на ксс стили, //! может понадобиться обновить ссылку потому что в видео другие версии, их можно выбирать на 
        сайте 

        в видео версия 5.1.1
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.0.2/css/bootstrap.min.css">
        
        для иконок делаем такуюже манипуляцию, в видео версия 5.15.4
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">



    Рассмотрим приложение, визуально делиться на 4 блока
        - хедер с информацией
        - блок фильтрации: поиск по имени + фильтры
        - список сотрудников
        - блок добавления нового сотрудника инпуты - имя + зарплата и кнопка добавить



    Начнем создавать такую структуру в проекте, в папку components будем складывать все остальные папки, использоваться для 
        именования будет кебаб стиль(через дефис)  employees-list-item , в каждой папке будет js(jsx - разницы нету) + css файл
        
            components
                app
                app-filter
                app-info
                employees-add-form
                employees-list
                employees-list-item
                search-panel

        
        Применение бутстрап стиля в компоненте - просто пишем название form-control и search-input - которые есть в бутстрапе и для 
        них соотносятся определенные стили

            const SearchPanel = () => {
                return (
                    <input type="text"
                            className="form-control search-input"


        
        Значение по умолчанию в реакте если не будет передано значение defaultValue

            <input type="text" className="list-group-item-input" defaultValue="1000$"/>


*/}

{/*    ====    10. Свойства компонентов - props    ====

    Свойства компонента(props) - предназначены для того чтобы заполнять контент компонента различным содержимым. Например если 
        имеется 10 карточек товара, то они будут однотипными по структуре и отличаются только содержимым, поэтому можно создать
        1 компонент - карточку и в props закидывать различное содержимое чтобы каждая карточка отображала свое.
        
            function WhoAmI (props) {
                return(
                    <div>
                    <h1>My name is {props.name}, surname - {props.surname}</h1>
                    <a href={props.link}>My profile</a>
                    </div>
                )
            }


            function App() {
                return (
                    <div className="App">
                    <WhoAmI name="John" surmane="Smith" link="facebook.com"/>
                    <WhoAmI name="Alex" surmane="Shepard" link="google.com"/>
                    </div>
                );
            }


        Можно сразу деструктуризировать - вытащив нужные свойства и тогда убрать слово props

             function WhoAmI ({name, surname, link}) {
               return(
                    <div>
                    <h1>My name is {name}, surname - {surname}</h1>


        //! В props можно передавать всё даже объекты и тогда прочитать нужно будет по name.firstName, потому что если оставить
        //! просто name то это будет объект и он не отобразиться напрямую на странице

            <WhoAmI name={{firstName: "John"}} surmane="Smith" link="facebook.com"/>

            function WhoAmI ({name, surname, link}) {
               return(
                    <div>
                    <h1>My name is {name.firstName}, surname - {surname}</h1>


        Функции - тогда в компоненте нужно будет вызвать эту ф-ю
                
            <WhoAmI name={ () => {return "John"} } surmane="Smith" link="facebook.com"/>

            function WhoAmI ({name, surname, link}) {
               return(
                    <div>
                    <h1>My name is { name() }, surname - {surname}</h1>



        //! Главное правило реакта что props внутри компонента не должны изменяться(иммутабельность).

    
*/}

{/*    ====    11. Практика свойств на проекте     ====

    Сделаем кастомизацию сотрудников( пока что 3 Джона Смита с одинаковой ЗП). Передадим props в компонент EmployeesListItem и 

            <EmployeesListItem name="John C." salary={800} />

        модифицируем его для работы с ними

            const EmployeesListItem = ({name, salary}) => {
                return (
                    <li className="list-group-item d-flex justify-content-between">
                        <span className="list-group-item-label">{name}</span>
                        <input type="text" className="list-group-item-input" defaultValue={salary + "$"}/>



    Теперь карточки сотрудников отличаются, но данные захардкожены(жестко зафиксированы) и если будет 1000 сотрудников нужно будет 
        вносить все данные руками. Чтобы такого не делать поработаем с данными, допустим с сервера они пришли в компонент App и 
        сохранились, создадим их там в формате массива который содержит объекты в которых есть свойства name и salary. И передадим
        их как свойства в нужный компонент EmployeesList. 

            function App() {
                const data = [
                    {name: "John C.", salary: 800},
                    {name: "Alex M.", salary: 300},
                    {name: "Carl W.", salary: 5000}
                ]

                <EmployeesList data={data}/>


        Теперь можем использовать данные которые пришли в props, но снова нужно будет вбивать все вручную например так
                
                <EmployeesListItem name={data[0].name} salary={data[0].salary} />

            и чтобы так не делать используем метод перебора массива map который при переборе возвращает НОВЫЙ массив объекто в 
            каждый объект поместив элемент JSX c свойствами из аналогичного(по порядку) объекта предыдущего массива, а значит 
            придерживается правила иммутабельности не изменять входящие данные, получим новый массив с элементами jsx и потом его
            выведем на страницу.

                const EmployeesList = ({data}) => {
                    
                    const elements = data.map( item => {
                        return <EmployeesListItem name={item.name} salary={item.salary} />
                    })

                    return (
                        <ul className="app-list list-group">
                            {elements}
                        </ul>
                    )
                }
                            
            Теперь список сотрудников формируется динамически.

            //! Можно улучшить запись добавлением спред оператора, тоесть при name={item.name} - мы вытаскиваем значение name из 
            объекта item и дальше также вытаскиваем salary, по сути мы присваиваем name = name и так как названия не меняются
            можно просто сделать спред оператор который сам распакует нам названия со значением что превратит объект
            {name: "John C.", salary: 800} в строку  - name: "John C.", salary: 800

                return <EmployeesListItem { ...item } />

    
*/}

{/*    ====    12. Работа со списками и алгоритм согласования     ====

    В консоли вылезла ошибка что каждый елемент списка должен иметь уникальное свойство ключ - "key".

    Процесс создания дом дерева затратный по ресурсам, на помощь ему приходит виртуал ДОМ. Но его построение тоже не очень
        дешево если используется много элементов, например список из 200 строк и одна в середине удалилась как в таком случае
        отработает приложение, тут и сработает механизм согласования(сверки, реконцеляции).  Или вместо корневого для
        списка тега li он измениться на div то реакт не изменяет узел а уничтожает его и создает заново вместе со списком из
        200 объектов, но если поменяется только стили у тега, то внутренности не будут уничтожены, а пресоздасться только корневой
        тег с новыми стилями и рекурсивно реакт пойдет смотреть есть ли отличия старого дерева объектов от новго который реакт
        создаст при выявлении отличий реакт перерисует в реальном ДОМ дереве только те елементы которые изменились.

        На базовом уровне сравнение списка идет по порядку, начиная с первого. Если елемент добавляется в конец то реакт пройдет
        по всему списку увидит что елементы одинаковые, найдет последний новый елемент и дорисует его. Но если мы помещаем новый
        елемент в начало списка, то он теперь будет первым и не будет равен предидущему первому, а предыдущий первый станет вторым
        и не будет равен старому второму, таким образом прийдется перерисовывать все елементы. Чтобы реакт быстрее сравнивал(имел
        какую то привязку, видел что элемент тот же и в нем ничего не изменилось) используют key и именно по нему реакт будет
        определять изменился елемент или нет. //! Ключи должны быть уникальными только среди своего списка. Если с сервера не пришел
        //! id (не написали) то допускается использование индекса элемента как ключа но такое допускается только если не будет
        //! меняться порядок элементов. Плохая практика использование для ключей ф-й по типу Math.random



    Захардкодим уникальные id в data
        
            const data = [
                {name: "John C.", salary: 800, increase: true, id: 1},
                {name: "Alex M.", salary: 300, increase: true, id: 2},
                {name: "Carl W.", salary: 5000, increase: false, id: 3}
            ]

        и в методе map будем использовать их как ключи, так как названия у нас не совпадают тоесть у нас будет key = id то нужно
        вытащить их отдельно для этого сделаем частичную деструктуризацию вытащив id, а остальные свойства сохраним в itemProps
        который деструктуризируем как раньше item

            const elements = data.map( item => {
                const {id, ...itemProps} = item
                return <EmployeesListItem key={id} { ...itemProps } />
            })
  
    
*/}

{/*    ====    13. Состояния компонентов     ====

    Состояние компонента(state) может динамически изменяться в отличие от свойств(например цифра в компоненте счетчике или номер 
        активного слайда в слайдере). Изначально состояние можно было создать только в классовом компоненте, потом с введение хуков
        такая возможность появилась и в функциональном. Поэтому рассмотрим state на примере классового компонента, чтобы понимать
        как оно работает.



    Продолжим в App переделав ф-й компонент WhoAmI в классовый. 

            function WhoAmI ({name, surname, link}) {
                return(
                    <div>
                    <h1>My name is {name}, surname - {surname}</h1>
                    <a href={link}>My profile</a>
                    </div>
                )
            }


        Для этого импортируем компонент из реакта. //! Когда класс вызывается он создает свой экземпляр и чтобы в него передались
        props нужно использовать конструктор, в нем принять эти props и чтобы их использовать пропишем слово супер и в него 
        передадим props. Эта возможность работы с prop приходит из Component от которого и наследуется наш классовый компонент.
        Теперь внутри каждого экземпляра класса будет свойство this.props - с объектом props(то что мы туда передали). Чтобы 
        каждый раз не писать this сделаем деструктуризацию в render и вытащим свойства из него.

            import { Component } from react;

            class WhoAmI extends Component {
                constructor(props) {
                    super(props)
                }
                render() {
                    const {name, surname, link} = this.props
                    return(
                    <div>
                        <h1>My name is {name}, surname - {surname}</h1>
                        <a href={link}>My profile</a>
                    </div >
                    )
                }
            }

        //! В консоле предупреждение о бесполезном конструкторе, так как мы тудеа ничего своего не добавили то его можно просто
        удалить. Но пока оставим его что бы знать что он нужен если мы захотим добавить в компонент свое поведение(ф-и или state).



    Так как props менять мы не должны то для того чтобы ввести динамику создадим свойство state в конструкторе - это такой объект
        в котором храняться различные свойства которые будут динамически изменяться. //! В нем можно делать много свойств и дописывать
        вложенные структуры. Используем значение years в компоненте обратившись как к обычному свойству в объекте this.state.years

            constructor(props) {
                super(props)
                this.state = {
                    years: 27
                }
            }


            <h1>My name is {name}, surname - {surname}, age - {this.state.years}</h1>



    Добавим кнопку с событием в компонент для смены значения свойства years. Передаем в onClick только название ф-и без вызова, 
        вызываться будет когда юзер будет кликать по кнопке. Теперь создадим этот метод через стрелочную ф-ю, //! через обычную
        ф-ю будет ошибка ???  - рассмотрим в следующих уроках. Видим что кнопка появилась для каждого компонента своя.

            nextYear = () => {
            }

            <button onClick={this.nextYear}>+++</button>



    Напрямую изменить(мутировать) state нельзя, тоесть нельзя написать this.state.years++ - не будет происходить изменение, для 
        этого нужно использовать комманду(ф-ю)  this.setState() - в себя она принимает аргумент - объект с новым состоянием(объектом)
        который прямо тут и конструируем - записываем свойство years в котором будет текущее состояние this.state.years - увеличиное
        на один, инкримент ++ - помещаем в префиксной форме - перед значением.

            nextYear = () => {
                this.setState({
                years: ++this.state.years
                })
            }


        теперь при нажатии на кнопку изменяется текст age компонента, причем для каждого компонента цифра храниться своя.
        //! Но видим что предупреждение о мутации в консоли не пропало, потому что мы снова меняем напрямую предыдущий state
        //! оператором ++, поэтому для увеличения или уменьшения используется такая запись  years: this.state.years + 1

            nextYear = () => {
                this.setState({
                years: this.state.years + 1
                })
            }



    //! Когда запускается setState - она производит перерисовку(запускает метод render) всего компонента с новым состоянием. 
    //! setState выполняется асинхронно и state в 95% случаев зависит от предыдущего state, тоесть когда увличивается с 30 до 31
    //! счетчик то мы знаем что перед 31 предыдущее состояние должно быть только 30 чтобы получить правильный результат. А из-за
    //! асинхронности может получиться так что предыдушее состояние еще не обновилось, а мы уже снова обновляем. Тоесть если 
    //! сейчас очень быстро клацать кнопку то может случиться так что счетчик собЪется и результат будет не таким как нам нужен.
    
    //! Так получается потому что несколько изменений состояний объединяются в одно и приоритет выполнения может быть отдан 
    //! другому работающему процессу и будет ждать его завершения, такая у реакта оптимизация работы.

    //! Чтобы от этого избавиться можно внутрь setState передать другую ф-ю тоесть коллбек, таким образом реакт будет ждать 
    //! выполнения предыдущего коллбека перед выполнением следующего. При этом ф-я принимает текущее состояние state и вместо записи 
    //! return мы берем в круглые скобки весь объект который она возвращает, и так как у нас state уже приходит без this, нам больше 
    //! не нужно его вытягивать из объекта и можно this удалить.

            nextYear = () => {
                this.setState(state => ({
                    years: state.years + 1
                }))
            }

        //! Если state не зависит от предыдущего, например вводиться в инпут новое значение которое не зависит от старого значения
        то можно передавать просто объект.



    //! В state может быть больше чем 1 свойство, возникает вопрос что будет с другими свойствами раз мы в setState указали только
    //! одно. setState меняет в state только то что мы указали, а остальное остается неизменным и не стирается.

    
*/}

{/*    ====    14. Самостоятельное задание на работу с состоянием     ====

    Домашнее задание по ссылке https://codepen.io/ihinstone/pen/QWvYePv

    
*/}

{/*    ====    15. События в реакт, вспоминаем this     ====

    onClick мы уже использовали, рассмотрим остальные с базовых понятий, продолжаем на проекте из 13 урока.

    Для назначения обработчика события в реакте прописываем событие в качестве аргумента в формате camelCase. Создадим форму с
        инпутом и создадим у него обработчик событий onInput. //! В JS onInput срабатывает когда впечатывается что то в инпут, а
        //! onChange - когда уводится фокус от элемента. В реакте они работают одинаково и зачастую используют onChange.
        Создадим и положим в него метод commitInputChanges, хотим чтобы при впечатывании текста он попадал в state. Для этого
        в state создадим свойство position(должность). Также вынесем в отдельные переменные position и years чтобы не писать
        часто this.state. //! addEventListener вызывать нигде не нужно реакт все делает сам когда компоненту или елементу
        //! назначаем событие. Для отмены стандартного поведения браузера в реакт работает только  event.preventDefault(); другие
        //! методы такие как return false в реакте работать не будут


             commitInputChanges = (e) => {
                this.setState({
                    position: e.target.value
                })
            }

            render() {
                const { name, surname, link } = this.props
                const {position, years} = this.state
                return (
                <div>
                    <button onClick={this.nextYear}>{this.state.text}</button>
                    <h1>My name is {name}, surname - {surname}, 
                        age - {years}, 
                        position - {position}</h1>
                    <a href={link}>My profile</a>
                    <form>
                    <span>Введите должность</span>
                    <input type="text" onChange={this.commitInputChanges} />
                    </form>
                </div >
                )
            }
            }

        

    //! Для методов всегда нужно использовать СТРЕЛОЧНЫЕ ф-и. Потому что this свой для каждого екземпляра класса(объекта созданного из
    //! этого класса). Когда работает с props и state тут всегда будет ссылка на данный екземпляр. А с обработчиками события сложнее
    //! когда событие срабатывает - контекст теряется, из-за того что ф-я события вызывается внутри другой ф-и - render при этом
    //! this становиться undefined и если просто сделать из стрелочной ф-и обычную то будет ошибка - не могу прочитать свойство у
    //! undefined когда выполняется setState, на этом этапе он и теряется. Ф-я setState вызывается внутри ф-и nextYear а она 
    //! вызывается внутри render.

             nextYear () {
                this.setState(state => ({
                    years: state.years + 1
                }))
            }


    //! Разберем все 3 варианта как избежать данной проблемы:

        //! 1) через bind. Прописываем в конструкторе эту строку  this.nextYear = this.nextYear.bind(this)
        //! Слева будет обычное свойство которое будет у екземпляра класса который был создан.
        //! С права обращаемся к методу this.nextYear - которые есть в классе и мы его байндим(привязываем)
        //! к конкретному екземпляру класса .bind(this). Если по простому то мы жестко привязываем метод из родительского класса к 
        //! созданному екземпляру. Так будет работать с конструкцией выше. 


            constructor(props) {
                super(props)
                this.state = {
                    years: 27,
                    text: '+++',
                    position: ''
                }
                this.nextYear = this.nextYear.bind(this)
            }

            //! неудобство в том что каждый метод который у нас используется в обработчиках событий нужно будет байндить.


        //! 2) записывать методы через стрелочную ф-ю (использовать синтаксис полей классов).


        //! 3) вызвать событие через анонимную стрелочную ф-ю(коллбек) в самом обработчике. Вызывается анонимная ф-я при клике, она 
        //! внутри себя вызовет  this.nextYear() и за счет того что эта коллбек ф-я стрелочная - this она берет у своего родителя 
        //! в нее попадет ссылка на наш екземпляр класса(объекта)

            <button onClick={ () => this.nextYear() }>{this.state.text}</button>

            //! неудобство что при каждом пересоздании компонента будет создаваться снова эта коллбек ф-я и проблема может быть
            //! если этот колбек дальше передается по props. При изменении props будет заново создаваться тот компонент в который
            //! этот коллбек передается потому что новый коллбек будет отличным от предыдущего, немного теряется оптимизация.

            //! Преимещество - можно передать аргумент в ф-ю. При этом нужно вреяную добавить событие в анонимную ф-ю, а в вызов
            //! ф-и можно добавить аргумент и принять его в методе.

            commitInputChanges = (e, color) => {
                console.log(color)
                this.setState({
                position: e.target.value
                })
            }

            <input type="text" onChange={ (e) => this.commitInputChanges(e, 'some color')} />

   
*/}

{/*    ====    16. Практика состояний на проекте     ====

    Открываем проект. Реализуем при клике на печеньку изменение состояния(state) в этом компоненте. Для этого переделаем компонент
        в классовый и создадим в нем state. Испортируем компонент из реакта, прописываем класс + екстенд компонент, создаем
        конструктор, в нем создаем state со свойством increase, всё что было до этого в компоненте помещаем в метод render
        и добавляем деструктуризацию переменных из this.props чтобы легче обращаться было. Добавим обработчик события и ф-ю
        для него.

        Так как будем изменять состояние в зависимости от того которое было раньше(тоггл) через ! - не(оно инвертирует предыдущее
        на противоположное, так как значение булево и их всего 2, получиться автоматический тогглер), то нужно записать коллбек
        и в нем используем деструктуризацию чтобы сразу вытащить свойство increase из state.

        Теперь значение increase будем брать не из props а из state, поэтому изменим деструктуризацию.

            import { Component } from 'react'
            import './employees-list-item.css';

            class EmployeesListItem extends Component {

                constructor(props) {
                    super(props)
                    this.state = {
                        increase: false
                    }
                }

                onIncrease = () => {
                    this.setState( ({increase}) => ({
                        increase: !increase
                    }))
                }


                render() {
                    const { name, salary } = this.props
                    const { increase } = this.state

                    let classNames = "list-group-item d-flex justify-content-between"
                        if (increase) {
                            classNames += " increase"
                    }

                    return (
                        <li className={classNames}>
                            <span className="list-group-item-label">{name}</span>
                            <input type="text" className="list-group-item-input" defaultValue={salary + "$"} />
                            <div className='d-flex justify-content-center align-items-center'>
                                <button type="button"
                                    className="btn-cookie btn-sm "
                                    onClick={this.onIncrease}>
                                    <i className="fas fa-cookie"></i>
                                </button>

                                <button type="button"
                                    className="btn-trash btn-sm ">
                                    <i className="fas fa-trash"></i>
                                </button>
                                <i className="fas fa-star"></i>
                            </div>
                        </li>
                    )
                }
            }

            export default EmployeesListItem;



    На локальном уровне у нас все работает, но данные глобальные которые в App у нас пока не изменяются.


    //todo Дом. задание. - при клике на span с именем нужно добавлять класс like для этого юзера, тогда будет зажигаться 
    //todo третий значек - звездочка.
    //! Сделано 

    
*/}

{/*    ====    17. Работа с формами, управляемые и неуправляемые компоненты     ====

    Формы в реакт очень похожи на аналоги в стандартной верстке, если не отменять стандартное поведение браузера то они будут
        перезагружать страницу. Отменять его в реакте можно только через event.preventDefault(). Все элементы форм поддерживают
        теже события(только onInput и onChange будут вести себя одинаково).


    
    Практиковаться с формой будем в файле addForm в проекте. Всё что будем вписывать в input должно сохраняться в нашем локальном
        state, поэтому переделаем компонент в классовый. В state будет два свойства - имя новосозданного сотрудника и количество
        денег - зарплата.

            this.state = {
                name: '',
                salary: ''  - //! строка потому что если установить 0 число то к нему добавляются цифры так как ввод строка
            }                  //! происходит конкатенация числа 0 со строкой ЕСЛИ инпут контролируемый

        Навесим обработчик события на оба инпута. И сделаем одну ф-ю для обоих обработчиков, смысл которой будет в том чтобы брать
        e.target.value и изменять необходимое свойство в state, это можно сделать с помощью ES6 синтаксиса. Так как мы не привязаны
        к тому что у нас хранится в свойстве до этого то делаем без коллбека. Сложность состоит в том как записать значение в нужное
        свойство. Для этого к инпутам добавим аттрибут name в котором будем указывать названия идентичные с названиями свойства в
        state, потом будем их брать и подставлять вместо названия изменяемого свойства как переменную, //! нужно обязательно брать в
        //! квадратные скобки чтобы не было ошибки.

            onValueChange = (e) => {
                this.setState({
                    [e.target.name]: e.target.value
                })
            }
        
            <input type="text"
                className="form-control new-post-label"
                placeholder="Как его зовут?"
                name='name'
                onChange={this.onValueChange} />
            <input type="number"
                className="form-control new-post-label"
                placeholder="З/П в $?"
                name='salary'
                onChange={this.onValueChange} />


        Эти инпуты у нас не управляемые(контролируемые) потому что значение вноситься только из инпута прямо в state но обратной
        связи нету. 
        
    
    
    Если нужно чтобы реакт компонент рендерил форму и контролировал её поведение в ответ на пользовательский ввод то нужно 
        добавить value = {} и в него помещать значение state. Такие элементы называются управляемыми.

            render() {
            const { name, salary } = this.state

            return (
                <div className="app-add-form">
                    <h3>Добавьте нового сотрудника</h3>
                    <form
                        className="add-form d-flex">
                        <input type="text"
                            className="form-control new-post-label"
                            placeholder="Как его зовут?"
                            name='name'
                            value={name}
                            onChange={this.onValueChange} />
                        <input type="number"
                            className="form-control new-post-label"
                            placeholder="З/П в $?"
                            name='salary'
                            value={salary}
                            onChange={this.onValueChange} />


        //! Зачем это делается - для синхронизации state с интерфейсом UI. Тоесть при вводе в инпут запускается setState который
        //! заново запустит render и при рендере значение будет браться не из поля, а из state. Это дает нам то что на все изменения
        //! интерфейс будет реагировать мгновенно, особенно это полезно при валидации данных, когда до момента записи в state данные
        //! проходят проверку на правильность и только тогда записываются в state. В основном используются именно такие контролируемые
        //! компоненты/елементы.

        //! Также существуют неуправляемые компоненты, значение которых храняться прямо в ДОМ дереве - тоесть в самом юзер интерфейсе,
        //! и это плохо потому что теряется возможность правильного использования инпутов и форм.

        //! Единственный инпут который в реакте всегда будет не управляемым - type='file' - позволяет юзеру загружать в него файл.
        //! так как файл в value отправить не можем))

        //todo есть приложенная статья на английском, но в конце там есть выводы можно почитать.
    
    
*/}

{/*    ====    18. Иммутабельность состояния, собственные события     ====

    Будем удалять сотрудников при нажимании на кнопку корзины. В реальном приложении когда сотрудник удалится со страницы он
        должен удалиться и на сервере(в базе данных). Чтобы удалился сотрудник нам нужно удалить его из данных. Сейчас иконка
        корзины находится в компоненте EmployeesListItem который не связан с данными которые лежат в App и чтобы связать их
        и отслеживать действия с ними нам нужно написать свои собственные события. Тогда если кликнем на корзинку на сотруднике
        он удалиться из данных они прийдут в компонент в котором рендерятся сотрудники, реакт увидит разницу и перерисует
        часть компонента которая изменилась.



    Откроем EmployeesList. Помним что как props мы можем передавать все что угодно, в том числе и ф-и. Передадим ф-ю в
        EmployeesListItem, она будет выводить в консоль сообщение - Deleted.

            return <EmployeesListItem 
                        key={id} 
                        { ...itemProps }
                        onDelete={() => console.log('Deleted')} />


        теперь можно ее использовать в компоненте EmployeesListItem, применим ее в компоненте на обработчик события,
        предварительно вытащив ее из props.

            const { name, salary, onDelete } = this.props

            <button type="button"
                className="btn-trash btn-sm "
                onClick={onDelete}>

            таким образом мы связали два компонента находящихся на разных уровнях иерархии - корневого и дочернего.


        Раз это работает с двумя элементами то передадим ф-ю из App в EmployeesList. Стрелочная ф-я которая будет
        получать какой то id и выводить его в консоль.

            <EmployeesList data={data} onDelete={id => console.log(id)}/>


        Теперь в EmployeesList будем использовать эту ф-ю предварительно достав ее из props и подставив вместо
        консольлога. И так как ф-я принимает один аргумент, то нужно ее вызвать с каким то аргументом. Тут мы
        как раз получали уникальный id для идентификации сотрудника(чтобы занести его в key), его и будем
        использовать.
        
            const EmployeesList = ({data, onDelete}) => {

            const elements = data.map( item => {
                const {id, ...itemProps} = item
                return <EmployeesListItem 
                        key={id} 
                        { ...itemProps }
                        onDelete={() => onDelete(id)} />

            теперь когда кликаем по корзине в консоль выводиться номер id сотрудника.


        Всё это произошло благодаря приему - передачи проперти(передачи свойств компонентов по иерархии) по научному это
        называется property drill - который рассмотрим позже. С самого верхнего компонента мы обозначили(написали) ф-ю
        передали дальше в компонент, там его вызвали с id(потому что тут есть id, а если вызвать в компоненте ниже то
        будет ошибка) и передали еще ниже и там она будет вызываться от клика юзера по кнопке. Таким образом можно
        передавать вниз и данные и методы и всё что угодно.

    

    На базе этого ф-ла приступим к удалению из массива данных data в App компоненте. Для динамической работы с 
        данными в реакте нам нужен state, в который и поместим эти данные. Переделываем App в классовый. data
        в нижний компонент теперь передаем из this.state.data. Ф-ю которую передавали теперь сделаем отдельным
        методом чтобы не писать код прямо при передаче, и чтобы иметь возможность его переиспользовать назовем
        его deleteItem. Теперь можно вместо консольлога работать с setState, сразу вытащим data из объекта
        state, но сразу возвращать объект не будем поэтому () эти скобки не ставим, а раскрывает фигурные
        скобки(тело ф-и) и будем выполнять в них определенные действия.

            class App extends Component {
            constructor(props) {
                super(props)
                this.state = {
                data: [
                    { name: "John C.", salary: 800, increase: true, id: 1 },
                    { name: "Alex M.", salary: 300, increase: true, id: 2 },
                    { name: "Carl W.", salary: 5000, increase: false, id: 3 }
                ]
                }
            }

            deleteItem = (id) => {
                this.setState(({data}) => {
                
                })
            }

            render() {
                return (
                <div className="app">
                    <AppInfo />

                    <div className="search-panel">
                    <SearchPanel />
                    <AppFilter />
                    </div>

                    <EmployeesList data={this.state.data} onDelete={this.deleteItem} />


        
        Алгоритм действий при удалении элемента из массива с объектами. Ориентироваться будем на id с которым
        этот метод вызывается. Теперь берем этот id и находим нужный объект внутри массива что бы его потом удалить.
        А потом будем изменять state чтобы созать новое состояние и запустить перерисовку компонента. id мы уже получили
        теперь рассмотрим как будем искать нужный объект. Это можно делать двумя способами:


        1) Находим индекс объекта в массиве по id через findIndex который вернет номер индекса объетка в котором нашел совпадения
        id, поместим его в переменную index и используем для удаления. 

            deleteItem = (id) => {
                this.setState(({data}) => {
                const index = data.findIndex(elem => elem.id === id)
                console.log(index)
                })
            }
        
            в консоль выводиться индекс елемента в массиве.

        теперь нужно удалить объект сохраняя иммутабельность state, тоесть state после создания не должен меняться и чтобы
        внести изменения создаем копию state вносим изменения в нее и присвоим эту копию как новый объект в state. Таким
        образом можно лего проследить что изменилось сравнивая новый и старый объект и это хорошо ложиться в концепцию
        реконцеляции(алгоритмов сравнения), также тестирование таких изменений будет легче. При таком подходе будет чуть
        больше расход памяти из-за создания множества объектов, но с характеристиками текущих гаджетов это не проблема.
        //todo приложена уникальная статья про иммутабельность в JS с примерами.

        //! Посмотрим как делать не нужно изменяя на прямую data в state. Методом splice просто удаляем елемент с полученым
        индексом, и вернем измененный объект чтобы setState его использовал. 
            
            deleteItem = (id) => {
                this.setState(({data}) => {
                const index = data.findIndex(elem => elem.id === id)
                data.splice(index, 1)
                return {
                    data: data
                }
                })
            }

            При нажатии на корзину сразу два сотрудника удаляются.
                
        Теперь как сделать правильно с использованием индекса - нужно создать новый массив который будет содержать все елементы
        старого массива но без того который удалим. Используем метод slice он копирует часть массива и создает новый. Скопируем
        часть до удаляемого элемента и после удаленного и склеим их в один массив. Первая переменная before будет копировать
        массив с начала(0 индекс) до полученого index, вторая переменная after будет копировать массив с index до конца.
        Потом их распакуем в новый массив и его вернем для присвоения data.

            deleteItem = (id) => {
                this.setState(({data}) => {
                const index = data.findIndex(elem => elem.id === id)

                const befor = data.slice(0, index)
                const after = data.slice(index + 1)

                const newArr = [ ...befor, ...after]

                return {
                    data: newArr
                }
                })
            }

        Такой метод не очень удобен потому что нужно 3 действия производить. Поэтому будем использовать метод 2.



        2) Для этого метода используем метод filter который создает новый массив со всеми елементами прошедшими проверку
        и будет сравнивать объекты по id, поэтому не нужно вычислять индекс. 

            deleteItem = (id) => {
                this.setState(({data}) => {
                    return {
                    data: data.filter(item => item.id !== id)
                    }
                })
            }

        данные отфильтруются и остануться только те елементы id которых не совпадает с полученным id.



    //todo домашнее задание - сделать добавление нового сотрудника чтобы он также появлялся в state. В новом объекте
    //todo будет полу id поэтому при создании новго объекта его нужно сгенерировать. Самый простой способ для этого
    //todo сделать новой свойство в конструкторе this.maxId = 4 и когда добавляем нового сотрудника брать из него
    //todo значение и увеличивать на единицу. Вариант сложнее - написать ф-ю по генерации случайного уникального id
    //todo или взять готовый пакет как например react-id-generator. Для отправки формы использовать событие
    //todo onSubmit
    //! Сделано.

   
*/}

{/*    ====    19. Практика. Подъем состояния     ====

    Сделаем чтобы в шапке подсчитывалось общее кол. сотрудников и Премию полчуча. Сложность тут состоит в том что
        app-info в котором это должно подсчитываться по структуре проекта лежит не там где у нас сотрудники и не там
        где мы можем отмечать их печеньками, но для подсчета ему нужно знать эти данные. Данные про сотрудников
        можно взять из state App, но данные про повышенных сотрудников у нас пока храняться в EmployeesListItem
        и не передаются в App. Тоесть нужно из EmployeesListItem передавать значения свойств в App а потом из
        state App будем брать всю информацию для app-info. Такой прием когда локал state одного компонента поднимаем
        выше по иерархии называется - подъемом состояния(state lifting).


    
    Сделаем новые методы в App. 

        onToggleIncrease - для замены того который меняет increase в EmployeesListItem, теперь будем прокидывать
        этот метод чтобы использовать в компоненте и изменять increase для state в App.

        onToggleRise - этот метод который используется при клике на имя сотрудника - идет на повышение - звездочка
        показывается. Вместо - onLike.

        В оба метода принимаем id нужного сотрудника. Пока что сделаем консольлоги в середине методов и пробросим
        их в компонент чтобы удостовериться что они отрабатывают.

            onToggleIncrease = (id) => {
                console.log(`Increase ${id}`)
            }

            <EmployeesList 
                data={this.state.data} 
                onDelete={this.deleteItem}
                onToggleIncrease={this.onToggleIncrease}


        в employees-list вытаскиваем их и прокидываем дальше с запуском коллбеком и передачей id в ф-и.

            return <EmployeesListItem 
                key={id} 
                { ...itemProps }
                onDelete={() => onDelete(id)}
                onToggleIncrease={() => onToggleIncrease(id)}
                onToggleRise={() => onToggleRise(id)} />


        Вытаскиваем их в EmployeesListItem и заменяем те которые были. Теперь нам не нужны локальные методы
        и локальный state в этом компоненте, потому что состояние будет контролироваться из App. И так как
        state локальный уже не нужен можно обратно переделать этот компонент в ф-й. Добавим increasу и rise
        в props которые приходят из App и в App добавим свойство rise в state, также добавим новое свойство
        в объект который добавляется в state.


        Теперь наполним внутренности новых методов. Алгоритм такой, вытаскиваем объект с которым работает 
        юзер по id, копируем его изменяем нужное свойство создать новый state(и поменять его уже в 
        компоненте). Рассмотрим два метода как это можно сделать.

        1) Снова сложный метод через нахождение индекса объекта. В setState вытягиваем data, потом находим
        индекс елемента, присваеваем часть data - объект по найденому индексу в old - эта переменная нужна
        для того чтобы брать старое значение изменяемого свойства. Потом копируем этот объект через
        деструктуризацию в объект который присвоим newItem(при этом он разворачивается на свойства) и через
        запятую к развернувшимся свойствам добавляем новое свойство со значением которое будет противоположно
        этому же значению из old - куска оригинального объекта(тут мы только считываем значение, и не меняем
        его) при этом если свойство с таким именем уже есть в объекте старое просто замениться на новое.
        В newArr создаем новый массив в который деструктуризируем(копируем и разворачиваем) начало data до 
        объекта с нужным индексом, сюда же добавляем новый измененный объект и дальше деструктуризируем
        оставшуюсья часть массива data, при индексе 1 например слайс можно представить в таком виде 
        - slice(index + 1) = slice(1+1) = slice(2) - итого эта ф-я вернет все объекты начиная со второго
        индекса включительно.

            onToggleIncrease = (id) => {
                this.setState(({data}) => {
                const index = data.findIndex(elem => elem.id === id)

                const old = data[index]
                const newItem = { ...old, increase: !old.increase}
                const newArr = [ ...data.slice(0, index), newItem, ...data.slice(index + 1)]

                return {
                    data: newArr
                }
                })
            }


        2) Этот способ аналогичен способу при удалении через фильтр, только тут мы используем
        map чтобы пройтись по всем элементам и найти нуйжный по id. Из setState сразу будем возвращать сразу новый 
        объект, поэтому будут дополнительные скобки. У него будет свойство data значением которого будет формироваться
        новый массив. Применение на data - map возвращает новый массив, при этом нужно прописывать return в конце в теле
        map. map проверяет каждый объект - и значит можно применить условие if, при нахождении нужного объекта мы 
        возвратим новый объект вместо старого с измененным свойством rise, return на этой итерации нужно потому что нужно
        каждый item возвращать, а при срабатывании условия ф-я заходит в if и потом не сработает общий return, значит его
        нужно дописать в if.


            onToggleRise = (id) => {
                this.setState(({ data }) => ({
                data: data.map(item => {
                    if (item.id === id) {
                    return { ...item, rise: !item.rise }
                    }
                    return item
                })
                }))
            }

        Работает, изменения можно отслеживать через установленное расширение вкладка components - смотрим на state, видим что есть
        некоторая задержка между нажатием на кнопку и изменением state - это потому что ф-я асинхронная. Если быстро понажимать
        на кнопку видим что state не меняется на каждый клик, а видим редкое переключение state с промежуточными, а потом и с 
        конечным результатом - так происходит потому что несколько вызовов setState объединяются в один.



    Теперь можно реализовывать счетчики в хедере. 
    //! Сначала попробовать самим подсчет делать в App а результаты передаватьчерез props в компонент app-info.

        Мое решение:  сначала попробовал сделать как константы там где прописаны методы - подсвечивало ошибку и не работало, 
        потом сделал как методы(ф-и) работало но не обновлялся в самом App-info компоненте, пришлось сделать как вызов ф-и.

               this.maxId = 4
            }

            totalEmloyee = () =>  this.state.data.length
            emloyeeRise = () => (this.state.data.filter(elem => elem.rise !== false)).length
            
            deleteItem = (id) => {


            <AppInfo totalEmloyee={this.totalEmloyee}
                  emloyeeRise={this.emloyeeRise}/>


            App-info
            <h2>Общее число сотрудников: {props.totalEmloyee()}</h2>


        Нормальное решение: константы делаются в методе рендер, так как рендер будет запускаться каждый раз при изменении state
        то они будут заново высчитываться и не нужно будет запускать их в компоненте App-info, а просто в него передавать уже
        вычисленные данные.

            render() {

                const totalEmloyee = () =>  this.state.data.length
                const emloyeeOnRise = () => this.state.data.filter(elem => elem.rise ).length  -//! возвращаем те елементы у которых
                                                                                                //! elem.rise  - true
                return (
                <div className="app">
                    <AppInfo totalEmloyee={totalEmloyee}
                            emloyeeRise={emloyeeOnRise}/>

            App-info
            const AppInfo = ({totalEmloyee, emloyeeOnRise}) => {
                return (
                    <div className="app-info">
                        <h1>Учет сотрудников в компании N</h1>
                        <h2>Общее число сотрудников: {totalEmloyee}</h2>


        //! Почему то была ошибка - Functions are not valid as a React child. Пришлось делать вызов для ф-й которые показывают
        //! количество сотрудников и на повышение. <h2>Общее число сотрудников: {totalEmloyee()}</h2>
        //! Наверное потому что эта ф-я нигде не вызывается, тоесть не рендерится как компонент и не незначена на событие.???
        //! Все решения в инете советуют или вызывать ф-ю или если это компонент указывать как компонент {< TotalEmloyee />}
        //! но для этого он должен быть настоящим компонентом(наверное ???)


    //! Так как автор сделал оба метода через map то видно что отличие в них только в названии свойства вместо 
        return { ...item, increase: !item.increase }  будет return { ...item, rise: !item.rise }. Если есть время и сроки проекта
        не горят то можно произвести оптимизацию(рефакторинг) чтобы исключить дублирование кода.

        Удалим старые методы и оставим один onToggleProp, в который будем передавать вторым аргументом prop - название того 
        свойства которое будет использоваться. //! Используем квадратные скобки чтобы не было ошибок. И передадим в компонент
        только один метод.

            onToggleProp = (id, prop) => {
                this.setState(({ data }) => ({
                data: data.map(item => {
                    if (item.id === id) {
                    return { ...item, [prop]: !item[prop] }
                    }
                    return item
                })
                }))
            }

            <EmployeesList
                data={this.state.data}
                onDelete={this.deleteItem}
                onToggleProp={this.onToggleProp} />


        В EmployeesList достаем из props этот метод, прокидываем дальше удаляя старые. //!Так как он вызывается тут то второй 
        //! аргумент тоже будем получать тоже тут, это должна быть строка и она должна быть получена с того элемента на котором
        //! происходит событие клика, поэтому присвоим в EmployeesListItem дата аттрибуты елементам, потому что это метки которые
        //! легко получить и это один из вариантов который можно применить к любому HTML элементу, в реакте они пишутся через 
        //! дефис как исключения. Присвоим data-toggle = "rise" и increase  и будем получать их значениея из события - е которое 
        //! приходит АВТОМАТИЧЕСКИ если ф-я предается как просто как ссылка на нее, а не как вызов со скобками. Из события по 
        //! currentTarget получаем значение аттрибута data-toggle. Используем currentTarget вместо обычного target чтобы игнорировать
        //! всплытие событий и получить именно тот елемент на котором произошел клик.

            return <EmployeesListItem 
                key={id} 
                { ...itemProps }
                onDelete={() => onDelete(id)}
                onToggleProp={ (e) => onToggleProp(id, e.currentTarget.getAttribute('data-toggle') ) } />


        EmployeesListItem

            return (
            <li className={classNames}>
                <span className="list-group-item-label" 
                      onClick={onToggleProp}
                      data-toggle = "rise">{name}</span>
                <input type="text" className="list-group-item-input" defaultValue={salary + "$"} />
                <div className='d-flex justify-content-center align-items-center'>
                    <button type="button"
                        className="btn-cookie btn-sm "
                        onClick={onToggleProp}
                        data-toggle = "increase">
                        <i className="fas fa-cookie"></i>
                    </button>



    //todo Домашнее задание - сделать так чтобы нельзя было добавлять пустых сотрудников. Чтобы имя было не меньше 3 символов
    //todo и чтобы были цифры в зарплате, способов тут много, на свое усмотрение.
    //! Сделано.

    
*/}

{/*    ====    20. Реакт фрагменты     ====

    Рассмотрим на тестовом примере. 

    Ранее учили что нужно всегда JSX код(структуру) оборачивать в один родительский елемент div. Но он ломает верстку там где
        используются grid, flex или 100% какой то ширины, и зачастую используют Fragment для обхода этой проблемы создали , 
        он лежыт в реакте и его можно выташить как и Component, существует 2 способа их применения:

        1) Импортуруем Fragment и теперь можно его использовать для замены div.

            import { Component, Fragment } from react;

            render() {
                const { name, surname, link } = this.props
                const {position, years} = this.state
                return (
                <Fragment>
                    ...
                </Fragment >

            теперь смотрим на DOM дерево и видим что их нету, в app в верстке идет набор всех елементов которые были внутри.


        2) При этом способе Fragment не импортируем. А вместо <div></div> - оставляем пустые скобки <></> это сокращенная
        запись, при которой реакт сам поймет что используется фрагмент


        //! Чаще всего div не используют, а используют синтаксис с пустыми скобками фрагмента, но там где мы делаем map
        //! для того чтобы незначить key такой синтаксис не пройдет,  нужно будет прописывать <React.Fragment key='223'
   
    
*/}

{/*    ====    21. Практика. Реализуем поиск и фильтры     ====

    Реализуем поиск и фильтры на проекте. 

    Начнем с поиска. Логика такая - юзер вводит в поле значение, так как будет контролируемый инпут то мы его сохраняем в локальном
        state(для этого переделаем компонент в классовый), эту же строку передадим через ф-ю из App в state общий в котором создадим 
        свойство с тем же названием как и в локальном и будем принимать его значение в качестве фильтра для новjuj отфильтрованного
        массива показываемого вместо обычного. Сделаем условие что если строка поиска пустая то массив из state ее будем фильровать
        таким образом отфильтрованный массив будет таким же как в state. Сначала реализуем поиск - если эта буква или комбинация букв
        есть в строке name объекта(а не по первой букве). У нас будет два метода в App(один изменяет state второй фильтрует фильтрует
        он будет получать строку по которой  фильтруем, а третий в компоненте app-filter он будет срабатывать при onChange записывать 
        строку в локальный state и запускать ф-ю которая прийдет из App передавая строку туда.


        Создаем новое свойство в state, вытащим его из state в rendere. Теперь напишем метод для поиcка через фильтр, принимать он
        будет массив в котором нужно искать соответствия и строку которую нужно искать. Пропишем условие на пустую строку - чтобы
        возвращался тот массив который был передан, если нет тогда будем возвращать отфильтрованный массив. Искать будем любое
        совпадение строки в свойстве объекта name через метод indexOf. Если он не находит совпадений то возвращает -1, если находит
        то возвращает индекс с которого найдено вхождение, может быть 0 поэтому делаем проверку того что он будет больше -1, 
        если да то этот элемент возвращается(помещается) в новый массив. Теперь нужно показать этот отфильтрованный массив,
        пока у нас отображается массив data, и поэтому нужно к нему применить наш метод чтобы отображался всегда отфильтрованный 
        массив. Для такого действия сделаем новую константу visibleData и будем отображать ее вместо data. Для установления term
        нового значения из инпута создадим метод onUpdateSearch он будет сетать в state строку которую методу передадут при 
        вызове его в компоненте при onChange. Этот метод нужно передать в компонент SearchPanel.

                        { name: "Carl W.", salary: 5000, increase: false, id: 3, rise: false }
                        ],
                    term: ''
                }
                this.maxId = 4
            }   


            searchEmployee = (items, term) => {
                if(term.length === 0) {
                return items
                }

                return items.filter(item => {
                return item.name.indexOf(term) > -1
                })
            }

            onUpdateSearch = (term) => {
                this.setState({term: term})  //!  this.setState({term}) - идентичные записи когда название полей совпадают
            }

            render() {
                const { data, term } = this.state
                const totalEmloyee = () => this.state.data.length
                const emloyeeOnRise = () => this.state.data.filter(elem => elem.rise).length
                const visibleData = this.searchEmployee(data, term)

                return (
                <div className="app">
                    <AppInfo totalEmloyee={totalEmloyee}
                    emloyeeRise={emloyeeOnRise} />

                    <div className="search-panel">
                    <SearchPanel onUpdateSearch={this.onUpdateSearch} />

            Пока больше кода не написали, можно протестировать работоспособность этого кода изменяя физически строку term в state.


        Работаем в компоненте SearchPanel. Переделаем его в классовый, сделаем state со свойством term и сделаем метод с таким же
        названием - onUpdateSearch(он будет сохранять строку в локал state и запускать переданную ф-ю onUpdateSearch из App
        с передачей в нее строчки из инпута) при запуске его по событию onChange. Сделаем значение инпута управляемым.

            import { Component } from 'react'

            class SearchPanel extends Component {
                constructor(props) {
                    super(props)
                    this.state = {
                        term: ''
                    }
                }

                onUpdateSearch = (e) => {
                    const term = e.target.value
                    this.setState({ term })
                    this.props.onUpdateSearch(term)
                }

                render() {
                    return (
                        <input type="text"
                            className="form-control search-input"
                            placeholder="Найти сотрудника"
                            value={this.state.term}
                            onChange={this.onUpdateSearch} />
                    )
                }
            }



    Остались фильтры.
    //todo попробовать сделать самостоятельно
    
    Мое решение. Создал новое свойство state - filter в него буду заносить строку по которой определять на что фильтровать массив.
        
              ],
            term: '',
            filter: ''
            }

        
        Методы filterOnSalary и filterOnRise будут фильтровать по зп больше 1000 и по свойству rise true. Задействоваться будут
        в switch если будет совпадать значение свойства filter с кейсом. onSetFilter - будет присваивать определенную строку в
        зависимости от того какую кнопку фильтра нажали, этот метод передается в компонент AppFilter. Если filter будет пустой то
        будет выведен стандартный список data по дефолту.

            filterOnSalary = (items) => {
               return items.filter(item => item.salary > 1000)
             }

                 filterOnRise = (items) => {
               return items.filter(item => item.rise )
             }

             onSetFilter = (filter) => {
               this.setState({filter})
             }


            render() 
                 let visibleData

                 switch (this.filter) {
                   case "salary":
                     visibleData = this.filterOnSalary(data)
                     break;
                   case 'rise':
                     visibleData = this.filterOnRise(data)
                     break;
                   default:
                     visibleData = this.searchEmployee(data, term)
                     break;
                 }


        AppFilter 

            <button type="button"
                    className="btn btn-light"
                    onClick={() => props.onSetFilter("")} >
                    Все сотрудники
            </button>
            <button type="button"
                    className="btn btn-outline-light"
                    onClick={() => props.onSetFilter("rise")} >
                    На повышение
            </button>
            <button type="button"
                    className="btn btn-outline-light"
                    onClick={() => props.onSetFilter("salary")} >
                    З/П больше 1000$
            </button>




    ФИЛЬТРЫ ПО УРОКУ.
    Логика - юзер выбирает фильтр в локальном компоненте AppFilter, поднимаем его на верх, фильтруем данные и отрисовываем на
        странице. 

    Фильтр представляем как обычную строку, в state создаем свойство filter с значением пустой строки, в него будем записывать
        выбранный фильтр

             ],
            term: '',
            filter: ''
            }


        В рендере вытащим сразу filter из state, и создадим новый метод для фильтрации, он будет принимать два аргумента - массив
        и фильтр по которому будем фильтровать. Фильтров у нас 3 - все сотрудники, на повышение и зп больше 1к. Поэтому нам нужно
        взять строчку filter и в зависимости от ее содержания выполнить действие, для проверки будем использовать switch который
        будет возвращать уже отфильтрованный массив из нашего метода.

            filterPost = (items, filter) => {
                switch (filter) {
                case 'rise':
                    return items.filter(item => item.rise)
                case 'moreThen1000':
                    return items.filter(item => item.salary > 1000)
                default:
                    return items
                }
            }

            render()
                const { data, term, filter } = this.state


        Как применить этот метод если у нас уже есть visibleData который возвращает отфильтрованный массив по поиску, но 
        одновременно с поиском у нас могут быть применены и фильтры. Тоесть нам нужно применить фильтры на массиве с поиском
        поэтому в visibleData помещаем вызов нового метода, но не на data, а на отфильтрованном массиве по поиску который был
        раньше в visibleData.

            let visibleData = this.filterPost(this.searchEmployee(data, term), filter)

        В ручную запишем в filter значение rise чтобы проверить работает метод или нет. Он работает показывает сотрудника, но
        если по нему кликнуть то rise у него измениться на false и он пропадет - будет пустое место, можно было бы сделать что
        если нету ни одного отображающегося элемента - то помещать уведомление об отсутствии найденных совпадений, но это будет в
        следующем модуле.


        Создадим еще 1 метод который будем передавать в компонент AppFilter

            onFilterSelect = (filter) => {
                this.setState({filter})
            }

            return 
            <AppFilter filter={filter}  onFilterSelect = {this.onFilterSelect} />
            


        AppFilter
        Теперь реализуем фильтры в самом компоненте с фильтрами. У нас есть 3 разных кнопки которые должны отслеживать определенное
        событие(в этом компоненте у нас не будет state, потому что кнопка не содержит никакого value, а на нее нажали и она что то
        сделала и эти действия мы передадим через props), чтобы не назначать на каждую кнопку обработчик вручную, потому что кнопок 
        в проекте может быть больше например 20, и когда их так много они нам приходят не в виде готовой верстки, а в массиве с данными
        так с ними работать будет даже удобнее и применяя такой подход будем выгоднее выглядеть в глазах нанимателя. Применим такой
        подход в этом компоненте.

        Создадим переменную buttonData с массивом в котором будут объекты со свойствами name и label. В name будет название которое
        будем помещать в state.filter, а в label будет надпись которая показвается на кнопке. Создадим переменную buttons в которую
        запишем результат map на buttonData в новый массив map будем возвращать как элемент кнопку но вместо названия используем 
        label,а как key для map используем name. 
        //! Сейчас в JS не считается ошибкой если в массиве после последнего елемента стоит запятая !! Проверить на объекте
        
        Но у нас есть разные классы стилей btn btn-light и btn-outline-light один когда 
        кнопка активна, второй когда не активна. Тут мы этого отследить не сможем. Можно в state.filter по умолчанию написать "all"
        и передавать значение этого свойства в компонент с фильтрами через props, тогда можно будет отследить какая кнопка активна 
        и ей назначить класс активности в этом же методе map. Создаем переменную active в которой проверяем на равенство значение
        filter из props и name, эта переменная будет содержать тру или фолс заменяет условие if. Потом используем в переменной 
        clazz - тернарный оператор и будем подставлять нужный класс в саму кнопку. Добавим в кнопку обработчик события и при клике
        будет вызываться коллбек ф-я которая запустит onFilterSelect из props и поместит в него как аргумент name из массива 
        объектов, так не нужно будет каждой кнопке вручную назначать обработчик события.

        Массив с кнопками выведем вместо обычной верстки кнопок.

            const AppFilter = (props) => {
            const buttonData = [
                { name: 'all', label: 'Все сотрудники' },
                { name: 'rise', label: 'На повышение' },
                { name: 'moreThen1000', label: 'З/П больше 1000$' },
            ]

            const buttons = buttonData.map(({ name, label }) => {
                const active = props.filter === name  // заменяет условие if 
                const clazz = active ? "btn-light" : "btn-outline-light"
                return (
                    <button type="button"
                        className={`btn ${clazz}`}
                        key={name}
                        onClick={() => props.onFilterSelect(name)}>
                        {label}
                    </button>
                )
            })
                
            return (
                <div className="btn-group">
                    {buttons}
                </div>
            )
        }


    Такой подход с конструкцией switch и хранением кнопок в массиве делает наше приложение легко масштабируемым, в него можно легко
        добавить еще фильтров без переписывания кучи кода.

    

    На данном этапе реализованы почти все ф-и приложения, на базовом уровне будут небольшие дополнения.

    //todo домашнее задание - сделать так чтобы при внесении в ячейку зп она сохранялась в state.
 
    
*/}

{/*    ====    22. Семантика и доступность контента     ====

    Семантика входит в общее понятие доступности. 
    Семантическая верстка - соблюдение правил разметки контента в зависимости от его смысловой нагрузки. Одно из ядер семантики -
        семантические теги в ХТМЛ: в шапке используем тег - header, подвал - footer и т.д. Из-за ограничений в реакте мы ломаем
        верстку и делаем ее невалидной(чаще всего это происходит со списками и таблицами) - использовать реакт фрагменты в случае
        надобности. Остальные правила верстки переносяться и в реакт: 1 - h1 на страницу, использование иерархии заголовков h, 
        обязательное использование аттрибута alt для картинок и другие важные вещи для СЕО.



    Программой могут пользоваться люди с ограниченными способностями - плохое зрение, нет возможности использовать мышку.
        Обычно доступность часто продумывается после создания большей части приложения.

        Представим что человек плохо видит и хочет воспользоваться программой, в ней много фото и товаров на которые нужно кликать,
        обычно такие люди пользуются спец. программами - скрин ридерами(одни увеличивают контент, одни озвучивают, а одни могут
        переводить в аналог шрифта для слепых). В понятие доступность вкладывается то что этой программой сможет воспользоваться
        кто угодно.

        //! Для того чтобы сделать верстку более доступной можно использовать аттрибуты ARIA. Для реакта aria аттрибуты это 
        //! исключения, они пишуться так как и в обычной верстке, например   aria-labelledby="aldress"
        //todo прочитать про эти аттрибуты http://prgssr.ru/development/ispolzovanie-aria-v-html5.html



    Рассмотрим вариант работы нашего приложения только с клавиатуры, всё работает кроме того что мы не можем выбрать имя сотрудника
        и поэтому не можем повысить его, такие мелочи нужно продумывать. Например аутлайны должны быть чтобы юзер понимал где 
        находится фокус, не блокировать какие то действия с клавиатуры. Клик прозводиться пробелом.

        //todo прочитать про аттрибуты таб индекс - ссылка тоже прикреплена - они позволяют ставить фокус на тех элементах которые
        //todo по умолчанию его не имеют например на div или span. 
        //todo посмотреть 2 доклада на ютубе по этим темам - посмотреть в видео, ссылок нету. 
   
    
*/}

{/*    ====    23. Стили в React. Inline Styles     ====
 
    Верстка со стилями может быть выполнена сразу, а потом сайт оживлен реактом, или может быть что верстка и стили пишуться по
        ходу создания компонентов. И тот и тот подход рабочий и правильный, выбираем какой нам нравиться или который используется
        в компании(на проекте).

    Инлайн стили - не самый предпочтительный метод стилизации, но иногда он просто не заменим, особенно при динамически изменяемом
        контенте. Во всех остальных случаях используем ксс классы.

        Для того чтобы назначить инлайн стили нам нужен аттрибут style, в реакте он принимает в себя объект, тоесть нужен объект
        со стилями.

        Допустим надо увеличить шрифт, открываем еще одни фигурные скобки(создаем объект) и в нем пишем ксс свойства кемел кейсом.

            <span className="list-group-item-label" 
                onClick={onToggleProp}
                data-toggle = "rise"
                style={{fontSize: 40}} >{name}</span>

            //! тут есть особенность - мы не прописывали единицы измерения для шрифта, в таких случаях реакт автоматически всегда
            //! подставляет пиксели. Если ужно другое значение то пишем руками и помещяем его в формат строки - " ".

            style={{fontSize: '40em', color: 'red'}}


        Такой подход удобен когда приходит отбъект со свойствами стилей. //! Но есть одна проблема, вендорные префиксы не будут
        //! ставиться автоматически - нужно будет прописывать их вручную.

        
*/}

{/*    ====    24. Стили в React. CSS и SASS/SCSS     ====
 
    Когда мы импортируем файл ксс в каждый нащ компонент при сборке вебпак соединяет их в один файл ксс. 
    
            import './employees-add-form.css';
    
    
    На момент записи видео реакт работает с SASS, НО НЕ С LESS. Создадим файл с препроцессором и назовем его также но с раширением
        scss. Перенесем содержимое ксс файла в scss. Комментируем обычный ксс файл и импортируем scss.

            import './employees-add-form.scss';

        при попытке запуска вылезает ошибка - failed to compile - не найден модуль sass. 
        

        Раньше устанавливали пакет node-sass но он стал устаревшим, теперь устанавливают просто sass.

            npm i sass --save


    //! Для того чтобы использовать переменный которые прописаны в отдельном файле не достаточно один раз имортировать его в 
    //! главный scss файл - index.scss. Нужно испортировать его в каждый файл scss в котором будут использоваться переменные.



    Если Посмотреть в ДОМ дерево то видно что в head вставлены все файлы со стилями отдельно. Так происходит потому что мы в 
        режиме разработки, а при финальной сборке проекта - билде для заливки на сервер все эти стили объеиняться в один файл.

   
*/}

{/*    ====    25. Стили в React. Динамические классы и стили     ====
 
    Динамический класс мы уже реализовывали - использовали условие чтобы сформировать строку с классами.

            let classNames = "list-group-item d-flex justify-content-between"
            if (increase) {
                classNames += " increase"
            }
            
            if (rise) {
                classNames += " like"
            }

        это и есть динамический класс который формируется в зависимости от условий. Похожая ситуайия была в app filter

            const active = props.filter === name
            const clazz = active ? "btn-light" : "btn-outline-light"


        У нас постоянно будет ситуация где какой то елемент будет активным или будет подсвечиваться какой то товар и т.д. особенно
        это касается тех компонентов которые формируются через перебор (map)



    Понятие динамических стилей касаются и объектов стилей которые передаются в аттрибут style. Например если есть свойство у 
        объекта colored от которого зависит цвет кнопки то можно дописать его в свойство style куда нужно передать объект и 
        через тернарный оператор в зависимости от значения colored будем передавать или объект или null. colored предварительно
        вытащим из state.

            const buttonData = [
                { name: 'all', label: 'Все сотрудники', colored: false },
                { name: 'rise', label: 'На повышение', colored: false },
                { name: 'moreThen1000', label: 'З/П больше 1000$', colored: true },
            ]

            const buttons = buttonData.map(({ name, label, colored }) => {
                const active = props.filter === name  // заменяет условие if 
                const clazz = active ? "btn-light" : "btn-outline-light"
                return (
                    <button type="button"
                        className={`btn ${clazz}`}
                        key={name}
                        onClick={() => props.onFilterSelect(name)}
                        style = { colored ? {color: "red"} : null }>
                        {label}
                    </button>

        //! такой метод может пригодиться если вообще нету файлов стилей или доступа к ним или подключена сторонняя библиотека 
        //! стилей тогда можно добавлять небольший участки кода при помощи такого синтаксиса, но если есть возможность то луче
        //! работать через ксс классы и лучше выносить такие конструкции в переменные даже если свойство всего одно.

                const clazz = active ? "btn-light" : "btn-outline-light"
                const styleRed = colored ? {color: "red"} : null
                return (
                    ...
                    onClick={() => props.onFilterSelect(name)}
                        style = { styleRed }>
                        {label}
                    ...

    
*/}

{/*    ====    26. Стили в React. Styled Components     ====
 
    Рассмотрим технологию CSS in JS. Ее конкретный представитель - styled components, у него есть аналоги но мы рассмотрим самый
        часто используемый вариант.



    Рассмотрим на тестовом проекте. Для использования этой технологии нужно ее установить в проект.

            npm i --save styled-components

        теперь можно стилизовать прямо внутри js файлов.



    В styled-components можно использовать условия, вложенности. Синтаксис заключается в создании переменной в ней обращаемся к
        styled - сущность из библиотеки, потом пишем какой тег хотим применить - а, и потом открываются бектики `` в которых и 
        пишется все стили для компонента. //! такой прием называется - тегированными шаблонными строками, они как раз и 
        //! используются для стилизации.

            const Button = styled.a`
                        ...
                        `



    Импортируем библиотеку в файл 

            import { Component, Fragment } from react;
            import styled from 'styled-components';


        теперь создадим блок который будет красиво оборачивать наши блоки

            const Wrapper = styled.div`
                width: 600px;
                margin: 80px auto 0 auto;
            `;

            function App() {
            return (
                <Wrapper>
                    <WhoAmI name="John" surmane="Smith" link="facebook.com" />
                    <WhoAmI name="Alex" surmane="Shepard" link="vk.com" />
                </Wrapper>

        В браузере видно что стили применились и в инспекторе можно увидеть созданный компонент с совершенно случайным названием
        класса это имеет как преимущества так и не достатки.



    Создадим еще несколько стайлед компонентся и подставим их вместо старых компонентов для закрепления:

            const EmpItem = styled.div`
                padding: 20px;
                margin-bottom: 15px;
                border-radius: 5px;
                box-shadow: 5px 5px 10px rgba(0, 0, 0, .2);
            `

            const Header = styled.h2`
                font-size: 22px;
            `

            export const Button = styled.button`
                display: block;
                padding: 5px 15px;
                background-color: gold;
                border: 1px solid rgba(rgba(0, 0, 0, .2);
                box-shadow: 5px 5px 10px rgba(0, 0, 0, .2);
            `

             return (
                <EmpItem>
                    <Button onClick={this.nextYear}>{this.state.text}</Button>
                    <Header>My name is {name}, surname - {surname},
                    age - {years},
                    position - {position}</Header>


        //! props, аргументы, аттрибуты - всё работает с этими компонентами также как с обычными.


        //! если стилизовать так каждый компонент/елемент то ксс классы нам не понадобяться, можно сделать файл с готовым набором 
        //! компонентов которые будем експортировать и использовать в других частях приложения. Так часто делают с заголовками,
        //! кнопками, карточками и т.д.



        //! Добавляем созданному компоненту Button дополнительные стили в компоненте index в который импортируем Button. В таком
        //! случае используем ф-ю styled и передаем в нее импортированный компонент, а в бектиках пишем дополнительные свойства.

            import { Button } from './App';
            import styled from 'styled-components';

            const BigButton = styled(Button)`
                margin: 0 auto;
                width: 245px;
            `

            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(
            <StrictMode>
                <App />
                <BigButton>+++</BigButton>


        Можно переопределить компонент, например сделать из кнопки - ссылку.

            <BigButton as="a" >+++</BigButton>



        //! Не обязательно внутри styled componenta делать все компоненты таким образом для задания им стилей. Так как он
        //! поддерживает вложенность можно прописать стили для дочерних компонентов прямо в созданном компоненте.

            const EmpItem = styled.div`
                padding: 20px;
                margin-bottom: 15px;
                border-radius: 5px;
                box-shadow: 5px 5px 10px rgba(0, 0, 0, .2);
                a {
                    display: block;
                    margin: 10px 0 10px 0;
                    color: black;
                }
                input {
                    display: block;
                    margin-top: 10px;
                }
            `



    //! Стайлед компонентс поддерживают свои props. В них можно передавать свойства и использовать их прямо внутри стилей,
        //! это может быть активная ссылка, выделеная карточка, важный сотрудник.

            <EmpItem active>

        передадим свойство active (в позиции тру?? наверное просто наявность его будет считаться за тру хотя автор говорит что мы
        его передавали раньше и делали его и оно в позиции тру у нас находиться, я не нашел в этих примерах). Теперь в стилях в этом
        компоненте будем использовать этот props вместо цвета. Открываем интерполяцию(так как мы в бектиках работаем) вписываем
        объект props и передаем коллбек ф-ю в которой проверяем свойство active в пропсах тру или фолсе и в зависимости от этого
        у нас будет динамический цвет

            a {
                display: block;
                margin: 10px 0 10px 0;
                color: ${props => props.active ? 'orange' : 'black' };



    //! Вендорные префиксы ставяться автоматически как в обычном аттрибуте style
    //! различные комбинации ксс селекторов работают как в обычном ксс
    //! псевдоселекторы и псевдо элементы тоже работают как в ксс (бефор, афтер)
    //! можно создавать анимации (смотреть документацию по плагину)
    


    ИТОГИ
        
    ПЛЮСЫ
        Избавились от ксс классов, теперь они часть компонента
        Инкапсуляция стилей (нету пересечений с ксс файлами, нету классов)
        Нет необходимости использовать методики нейминга классов
        Использование props и условий
        Вендорные префиксы ставяться автоматически

    МИНУСЫ
        Нужно к этому привыкать
        Можно запутаться где какой тег находиться если будет много верстки и нужно создавать много стайлед компонентс
        Все условия которые есть в стайлед компонентс можно реализовать и стилями, в некоторых случаях так даже понятнее
        Название стилей в инспекторе браузера превращаются в кашу - намного сложнее пользоваться инпектором и находить нужный 
            елемент
        Так как ксс уже в JS то отдельно закешировать файлы стилей уже не сможем
        Если ошибиться при создании стайлед компонента то приложение упадет, а если такая ошибка была бы в ксс то просто не 
            применились бы стили

    
*/}

{/*    ====    27. Стили в React. Готовые библиотеки со стилями     ====
 
    Рассмотрим способ который значительно ускоряет разработку когда стилистика не на первом месте, а важен функционал - приложения
        для внутреннего использования можно использовать набор уже готовых компонентов - (bootstrap и аналоги но для компонентов )
         - админки, формы. 


    Для реакта есть React bootstrap(и аналоги, один из самых популярных Matherial UI) - эти библиотеки берут то что было в 
        оригинальном буттстрап и создают подготоваленные для реакта компоненты. 


    Протестируем на тестовом приложении. Устанавливаем реакт бетстрап в проект (версия 5.1 на момент записи видео)

            npm i react-bootstrap@next bootstrap@5.1.0 --save


        импортируем в главный файл index.js или app.js обычный бутстрап - он нужен для работы библиотеки.

            import 'bootstrap/dist/css/bootstrap.min.css';



    Начнем с сетки ограничивающей контент - сбоку на сайте библиотеки - Layout - grid system. Для теста создадим в корне файл
        BootstrapTest.js и в нем будем писать. Для красивой структуры нам понадобится container, row и col которые сейчас 
        компоненты, а в обычном бутстрапе были классами. Нужно их импортировать, создадим компонент который будет возвращать
        структуру (возьмем из примера на сайте) и експортнем его.

            import { Container, Row, Col } from 'react-bootstrap'

            const BootstrapTest = () => {
                return (
                    <Container>
                        <Row>
                            <Col>1 of 2</Col>
                            <Col>2 of 2</Col>
                        </Row>
                    </Container>
                )
            }

            export default BootstrapTest


        Импортируем его в index.js и ставим в разметку после BigButton. Видим что появились 2 колонки после кнопки и да такое
        можно было сделать просто используя бутстрап классы, но дальше на сайте библиотеки есть Components которые уже так просто
        не создать, и они уже адаптированы под реакт - например слайдер(Carousel)


        
    //todo Почитать про ксс  modules - говорит очень редко встречаются поэтому отдельный урок по ним делать не будет.

    
*/}

{/*    ====    28. Поля классов и static     ====
 
    Class Fields
    Частично разбирали в JS в уроке про инкапсуляцию, теперь разберем по отношению к реакту. На момент записи курса это был 
        експериментальный синтаксис (но в 22 году должен был ввестись полностью) но если использовать с криейт реакт апп то 
        автоматически переводился в старый синтаксис поддерживающийся всеми браузерами.



    Этот синтаксис мы использовали когда прописывали методы как стрелочные ф-и - делали это для того чтобы закрепить за ними
        контекст вызова и не биндить каждый раз метод к екземпляру класса.

            onValueChange = (e) => {
                this.setState({
                    [e.target.name]: e.target.value
                })
            }



    Вторая возможность которую используют в классовых компонентах относящаяся к class fields - создание любых свойств без 
        конструктора, тоесть вместо такого

            constructor(props) {
                super(props)
                this.state = {
                    name: '',
                    salary: ''
                }
            }

        можно сделать так - как будто создаем переменную но без указания ключевым словом что это переменная

            state = {
                name: '',
                salary: ''
            }



    Следующая возможность связанна с ключевым словом static. Если вызвать метод random у класса Math - Math.random()? то вернет
        случайное число от нуля до единицы //! и при этом не создается екземпляр класса, а метод вызывается прямо на классе.
        Такие методы и свойства которые можно использовать без создания екземпляра класса через New - называются статическими.
        
        Если мы вызовем метод у нашего класса таким образом EmployeesAddForm.onValueChange() - будет ошибка - is not a function
        Если нам нужно иметь возможность так вызывать МЕТОД то мы можем сделать его статическим (это функционал JS). Создадим
        метод onLog с ключевым словом static

            static onLog = () => {
                console.log('Hey')
            }

            вызываем его после класса перед експортом - в консоли появилось сообщение

            EmployeesAddForm.onLog()

        

    //! А class fields кроме методов позволяют сделать таким образом и свойства, когда для класса должно быть общее свойство

            static logged = 'on'

            console.log(EmployeesAddForm.logged) - сработает и выведет значение свойства


    
    //! Такие методы можно использовать для создания мини библиотеки - как библиотека Math, а свойства полезны когда для разных
    //! екземпляров класса было общее свойство которое можно использовать, например стандартное значение какой то величины.

    
*/}

{/*    ====    29. Заключение модуля     ====
 
    //todo посмотреть проект для закрепления базы - поискать в уроке или по ссылке в видео / доделать лп-црм(своё)
    
*/}



//==============================================  СРЕДНИЙ ФУНДАМЕНТАЛЬНЫЙ УРОВЕНЬ ==============================================\\

{/*    ====    01. Что такое API и как работают реальные приложения     ====
 
    API - application programming interface. Самое простое объяснение от автора - API - это набор готовых ф-й и свойств которые
        можно использовать.

        Как пример - представим что разрабатываем мобильное приожение и нам нужно взаимодействовать с блютузом. Каким то образом
        нужно обратиться к програмным внутренностям телефона и сказать - в такой то момент сделай такое действие с блютузом. Эти
        програмные внутренности и называются API - Bluetooth API. Если хотим взаимодействовать с акселерометром то у него тоже
        будет свой API, яркость экрана - тоже API - набор готовых ф-й к которым мы будем обращаться. Работа с DOM деревом происходит
        тоже через DOM API - метод - document.getElementById и другие.


        В своей работе будем встречать множество API даже експериментальных, например -  Web Bluetooth API в некоторых браузерах
        через  который можно обращаться к объекту Bluetooth.


        В обучении использовали сервис - jsonplaceholder - это тоже API для тестирования и прототипирования - тут мы делали запрос
        и получали данные.



    Работа с API делиться на 3 этапа:

        1 как выполняем операцию - отпрака запроса(GET, POST) или запуск скрипта в той среде где работает API(например вызов алерт
            в консоли браузера - потому что там есть DOM API, при этом алерт в терминале редактора кода не работает потому что там
            не работает - нету DOM API)

        2 какие данные даем API - данные для регистрации, пароль и т.д. (этого пункта может и не быть)

        3 результат(ответ/response) - набор данных или активация сторонней ф-и(например включить поиск блютуз устройств)



    Бесплатных нормальных API для фронтенда не так уж много. 
        
        - API of ice and fire (по вселенной игры престолов)
        - pokeapi.co (апи по покемонам) 
        - Marvel api (developer.marvel.com)- требует авторизацию и ключ, с ним будем работать в новом приложении 
        - openweathermap.org/api - сервис с погодой, часто дают на собесах(нужна регистрация и ключ)
        - newsapi.org - апи по новостям, можно создать свою новостную ленту по запросам

        На гитхабе (public-apis/public-apis) есть сборник публичных апи - нужно тестировать перед использованием какие подходят. 


*/}

{/*    ====    02. Новый проект и работа с сервером     ====
 
    Будем делать приложение в котором показывается информация по героям и комиксам марвел - информация тянется с марвел апи.

    Зарегистрируемся на developer.marvel.com. Иногда сервис глючит и пишет get api key вместо показа аккаунта юзера и при переходе
        на интерактивную документацию - нужно клацнуть - get key и оно должно пролагать и закинуть в аккаунт - там есть два ключа
        публичный и приватный. Для запросов нам нужен публичный ключ, количество запросов в день - 3000, ниже в поле autorized 
        referrers нужно поставить - *.  и сохранить в аккаунте - это нужно чтобы делать кроссбраузерные(с одной страницы браузера на
        другую) запросы, тоесть когда запускаем сервер реакта на локалхосте чтобы был доступ до API.
    


    Можно сверстать макет приложения самому или скачать уже готовую верстку и разбить на компоненты, но в таком случае названия не
        будут совпадать с теми которые в курсе, или можно скачать уже готовую структуру. 
        

        
    Создадим папку services - это та часть приложения которая будет общаться со сторонними ресурсами. В ней создадим файл 
        MarvelSevices.js. В нем создаем класс MarvelService - без extends - он будет на чистом js поэтому от реакта ему ничего не
        нужно наследовать. В нем будет ф-я для запроса данных из url из курса по js. Будет запрос через фетч с нужного url и если
        нету ошибки - преобразован в json и возвращен из ф-и, а если будет ошибка(серверная) то покажем ее. Модифицируем ф-ю в 
        метод( преобразовали в колбек (стрелочную ф-ю))

            class MarvelService {
                getResource = async (url) => {
                    let res = await fetch(url)

                    if(!res.ok) {
                        throw new Error(`Could not fetch ${url}, status: ${res.status}`)
                    }

                    return await res.json();
                }
            }



        Теперь нужно делать запросы к нашему API для этого добавим еще методы:

        Метод getAllCharacters будет получать всех персонажей, он будет возвращать данные которые получили с помощью метода
        getResource - знаем что этот метод отдаст данные в формате json, так что нужно сформировать запрос, для этого зайдем на сайт
        api marvel в раздел interactive api tester, ищем characters - листаем ниже и нажимаем try it. Получили ответ в окне и в 
        ответе видим - объект с разными свойствами, в нем есть объект data, a в нем массив с объектами - results - его и будем 
        использовать.

            getAllCharacters = () => {
                return this.getResource(url)
            }

        теперь чтобы получить такой ответ в приложении нужно выше скопировать Request URL - в нем в конце уже приписан публичный
        api key от нашего аккаунта. Втсавим эту строку вместо url в getResource - как строку.(строчка при копировании может 
        разъединиться - смотреть на ощибку если будет). Экспортируем класс.
        //! скопировать свою строку



    Теперь протестируем в index.js этот запрос, импортируем класс, и теперь чтобы с ним работать нужно создать екземпляр класса
        marvelService потом обращаемся к нему, запускаем метод getAllCharacters он вернет промис поэтому пишем then и в скобках
        пишем колбек ф-ю которая принимаем аргумент res и выводит его в консоль

            import MarvelService from './services/MarvelSevices';

            const marvelService = new MarvelService();

            marvelService.getAllCharacters().then(res => console.log(res))

        в консоли видим тот же объект который видели на сайте в окошке. В results - массив из 20 персонажей. Но в верстке у нас
        только 9 ячеек под персонажей, так бывает. Остальные у нас будут подгружаться при клике на кнопку, тоесть нам нужно 
        лимитировать количество в запросе для этого на сайте выше "реквест урл" смотрим как это сделать. Есть специальное поле
        которое называется limit в него указываем 9. Также есть свойство offset - это отступ от начала массива(пропуск первых 210
        персонажей потому что у них не у всех есть картинки, можно поиграться с этим отступом и настроить другой). Снова клацаем на
        Try it и теперь url сменился на другой с новыми параметрами - вставим новый путь вместо старого.



        Создадим новый метод в MarvelService который будет делать запрос по id персонажа, на сайте вторая строка.

            getCharacter = (id) => {
                return this.getResource(`https/ - моя строка characters/${id}?api-key`)
            }

        и вызовем его в index - id - пока будет статичным 1011052 

            marvelService.getCharacter(1011052).then(res => console.log(res))


        теперь перейдем прямо к data result - массиву чтобы показать  именно персонажа, а не весь объект в котором он пришел, также
        сделаем и для всех персонажей

            marvelService.getAllCharacters().then(res => res.data.results.forEach(item => console.log(item.name)))

            marvelService.getCharacter(1011052).then(res => console.log(res.data.results[0].name))



    Модифицируем класс MarvelService чтобы избежать дублирование кода, вынесем базовый путь и апиключ в переменные:

            _apiBase = 'https/... public/'
            _apiKey = 'api-key'


            getAllCharacters = () => {
                return this.getResource(`${this._apiBase}characters?limit=9&offset=210&${this._apiKey}`)
            }

            getCharacter = (id) => {
                return this.getResource(`${this._apiBase}characters/${id}?${this._apiKey}`)
            }

    //! Добавить url и ключ и протестировать на работоспособность


*/}

{/*    ====    03. Трансформация данных и компонент со случайным персонажем     ====
 
    В этом уроке реализуем компонент со случайным персонажем (логика такая - получаем данные о персонаже и отображаем их в окне,
        а в соседнем окне по клику на кнопку будем менять этого персонажа), трансформируем данные в более приятный формат.
        В первой версии этого приложения еще будем работать с классами и хранить состояние компонента в этом же компоненте, а не
        централизовано как в предыдущем приложении.


    За показ случайного персонажа отвечает компонент - RandomChar, так как заготовка у нас ф-я, а нам нужно будет получить в этом
        компоненте данные и сохранять их, то нужно переделать его в классовый компонент. Импортируем компонент, пишем что это класс
        и помещаем всё содержимое внутрь метода render. Для хранения состояния создадим state синтаксисом полей классов без 
        конструтора, создадим нужные свойства которым зададим начальные значения null.

            import {Component} from 'react'

            class RandomChar extends Component {
                state = {
                    name: null,
                    description: null,
                    thumbnail: null,
                    homepage: null,
                    wiki: null
                }

                render() {
                    return (


        теперь будем использовать эти данные в верстке, сделав деструктуризацию state. 

            const {name, description, thumbnail, homepage, wiki} = this.state

        

        Далее будем получать данные и сохранять их в state. Вырезаем запрос на сервер который делали в indexe в текущий компонент.
        убрали const и получилось новое свойство marvelService внутри класса RandomChar. Будем использовать его в методе который
        будет обращаться к серверу, получать данные и записывать их в state, так как нам нужен 1 персонаж будем использовать
        метод getCharacter. В него будем передавать id который будет случайным(пока для проверки захардкодим номер) далее 
        обрабатываем результат работы метода(приходят данные в формате json) - (then) - получаем результат и сделаем колбек ф-ю
        котора сформирут наш state, так как он не зависит от предыдущего делаем просто новый объект. В него каждому свойству будем
        присваивать значение из объекта res из его свойвта data у которого есть свойство results которое хранит массив с данными и
        так как использован мето для одного персонажа, то массив состоит из одного объекта, к нему и обращаемся по нулевому индексу
        res.data.results[0].  Для картинки показа thumbnail - это свойство хранит объект который состоит из url в свойстве path и 
        расширения картинки extension - jpg нужно их сконкатенировать в одну строку. Для получения ссылок - они храняться в свойстве
        urls как массив с двумя объектами поэтому нужно обращаться по 0 и 1му индексу.

            import MarvelService from '../../services/MarvelSevices';

            marvelService = new MarvelService();

            updateChar = () => {
                const id = 101105
                this.marvelService
                    .getCharacter(id)
                    .then(res => {
                        this.setState({
                            name: res.data.results[0].name,
                            description: res.data.results[0].description,
                            thumbnail: res.data.results[0].thumbnail.path + '.' + res.data.results[0].thumbnail.extension,
                            homepage: res.data.results[0].urls[0].url ,
                            wiki: res.data.results[0].urls[1].url
                        })
                    })
            }


        теперь нужно запускать этот метод при запуске приложения и когда юзер будет нажимать на кнопку. 
        //! Для того чтобы запускался метод при запуске приложения создадим конструктор и запустим метод в нем. Видим что данные
        //! подставились, но в редакторе кода пишет предупреждение(ворнинг) - нельзя использовать setState в компоненте который
        //! еще не смонтировался, это может привести к багам. Так происходит потому что метод updateChar вызывается в 
        //! конструкторе еще до того как была построена верстка. Поэтому вызов методов в конструкторе особенно тех которые общаются
        //! с сервером или подписываются на сервисы - очень плохая практика.

            constructor(props) {
                super(props)
                this.updateChar()
            }
        
        На несколько уроков оставим так пока не изучим теорию как сделать правильно.


        Сделаем случайный id. //! опытным путем обнаружено что большинство персонажей находяться в промежутке 1011400 - 1011000
        Делаем случайное число в диапазон от 1011000 до 1011400 (400) и потом добавим его к минимальному числу с которого начинаются
        персонажи. Иногда попадается номер на котором нет персонажа и поэтому надо будет сделать проверку на ошибки.
            
            const id = Math.floor(Math.random() * (1011400 - 1011000) + 1011000)



    Так как получение данных для персонажа будет не только в этом компоненте(еще в боковой колонке), а может быть в нескольких
        компонентах, то чтобы не копировать в каждый один и тот же код - перенесем его в MarvelServices. На зовем его 
        _transformCharacter(название с нижним подчеркиванием чтобы подчеркнуть что изменение этого метода повлияет не только на этот
        компонент) - в нем будем получать данные(большой объект с кучей ненужной информации) и возвращать трансформированный объект,
        только с нужными данными и структурой.

            _transformCharacter = (res) => {
                return {
                    name: res.data.results[0].name,
                    description: res.data.results[0].description,
                    thumbnail: res.data.results[0].thumbnail.path + '.' + res.data.results[0].thumbnail.extension,
                    homepage: res.data.results[0].urls[0].url ,
                    wiki: res.data.results[0].urls[1].url
                }
            }

        теперь применим его в методе getCharacter модифицировав его (добавили сохранение пришедшего объекта и асинк эвейт для того
        чтобы ждать полученния ответа от сервера)

            getCharacter = async (id) => {
                const res = await this.getResource(`${this._apiBase}characters/${id}?${this._apiKey}`)
                return this._transformCharacter(res)
            }


        теперь можно в RandomChar изменить метод, теперь в сетстейт помещается просто объект который приходит после запуска 
        getCharacter

            this.marvelService
                .getCharacter(id)
                .then(res => {
                    this.setState(res)
                })


        вместо длинного пути вытаскиания персонажа в каждом свойстве можно сразу обратиться к нему и дергать нужное, так код будет
        более читабельным
        
            getCharacter = async (id) => {
                const res = await this.getResource(`${this._apiBase}characters/${id}?${this._apiKey}`)
                return this._transformCharacter(res.data.results[0])
            }

            _transformCharacter = (char) => {
                return {
                    name: char.name,
                    description: char.description,
                    thumbnail: char.thumbnail.path + '.' + char.thumbnail.extension,
                    homepage: char.urls[0].url ,
                    wiki: char.urls[1].url
                }
            }



        Сделаем такую же модификацию при получении всех персонажей, но так как в results будет уже массив объектов. а не один
        объект то его нужно перебрать методом map сделав новый массив с нужными нам объектами. В map передали ф-ю и она получается
        будет колбек ф-й которая будет делать что то с каждым элементом по очереди(возвращать новый объект)

            getAllCharacters = async () => {
                const res = await this.getResource(`${this._apiBase}characters?limit=9&offset=210&${this._apiKey}`)
                return res.data.results.map(this._transformCharacter)
            }


        //! для проверки  изменили метод и вывели в консоль результат, видим что вывелся массив из 9ти объектов 2 раза, 2 раза
        //! вывелся потому что из-за запуска в конструкторе пошло 2 запроса.

            updateChar = () => {
                const id = Math.floor(Math.random() * (1011400 - 1011000) + 1011000)
                this.marvelService
                    .getAllCharacters
                    .then(res => console.log(res))
            


    Доработаем state, сейчас в нем сразу идут свойства для персонажа, но в нем может потребоваться хранение других данных, например
        индикатор загрузки или данные об ошибке, поэтому поместим данные о персонаже в свойство char с пустым объектом, это тоже 
        самое что и все свойства со значением null.

            state = {
                char: {}
            }


        теперь нужно исправить путь к объекту персонажа, заодно вынесем сохранение персонажа в state в отдельный метод потому что
        он будет повторяться. onCharLoaded помещает пришедший в него объект в state ( {char} - сократили от {char: char}). А в 
        updateChar теперь просто помещаем этот метод и при использовании в промисах, в ф-ю которая находиться в then будет 
        автоматически подставляться тот аргумент который придет в then (как и в случае с map выше)

            onCharLoaded = (char) => {
                this.setState({char})
            }

            updateChar = () => {
                const id = Math.floor(Math.random() * (1011400 - 1011000) + 1011000)
                this.marvelService
                    .getCharacter(id)
                    .then(this.onCharLoaded)
            }

        деструктуризация при этом тоже измениться

            const {char: {name, description, thumbnail, homepage, wiki}} = this.state



    //! Когда в приложении есть взаимодействие с сервером(почти всегда), то лучше сетевой код отделять от основного, так можно
    //! использовать его в разных частях приложения и сделать код чище.



    //todo Домашее задание. Во многих персонажах нету данных о картинке и описании. На картинку поставлена заглушка на сервере,
    //todo а для описания нет. 
    //todo 1 - НУЖНО выводить текст - "данных о персонаже нет", если данные описания будут пустыми.
        
    //todo 2 - НУЖНО если описание слишком большое для карточки сделать его обрезку в троеточие.
        

*/}

{/*    ====    04. Хороший тон приложения (спиннер, ошибки...)     ====
 
    Домашка. 
        Моя реализация 1 
        В компоненте View прописал
            const descriptionRes = description ? description : "There is no description for this character"


        Иван реализовал оба домашних задания в сервисес - _transformCharacter
            description: char.description ? `${char.description.slice(0, 210)}...` : 'There is no description for this character',




    Для того чтобы юзер не ушел с сайта пока происходит запрос к стороннему серверу(время ответа не зависит от нашей оптимизации и
        может составлять около 10 секунд если слабый интернет или сервер под нагрузкой), ему нужно показать что сайт работает и идет
        какой-то процесс(загрузки) например крутящийся спинер. А если произошла ошибка то нужно показать это, чтобы юзер не ждал
        напрасно загрузки которая не произойдет. Применим эту практику для компонента со случайным персонажем.

    
    Для отображения загрузки используется спиннер(анимированная картинка). //! выбрать и скачать ее в проект. 
        Создадим компонент spinner для того чтобы его можно быо использовать в любом другом месте приложения импортировав.
        //! автор скопировал код компонента из заготовки в уроке spinner, в нем используется svg картинка с задаными с аттрибутами
        //! если заменять в этой верстке другую картинку svg то нужно будет вносить правки, в консоли будет подсказываться
        //! если будет какая-то ошибка. Пока оставил как есть.

    
    Теперь spinner можно использовать в компоненте RandomChar. Импортируем его, создаем в state свойство loading со значением true,
        в деструктуризации вытягиваем это свойство в переменную, и перед return создадим условие - если loading - true то return
        компонент Spinner. И так как  loading у нас пока всегда true, сработает условие и функция render увидит ключевое слово
        return в условии, она вернет компонент Spinner и прекратит работу(не пойдет к return с версткой). 
        //! такая конструкция когда загружается какой то компонент из условия называется - условный рендеринг
        
            import Spinner from '../spinner/Spinner'

            state = {
                char: {},
                loading: true
            }

            render() {
                const {char: {name, description, thumbnail, homepage, wiki}, loading} = this.state

                if(loading) {
                    return <Spinner />
                }

                return ( ...

        таким образом мы проверили что Spinner работает, но пока он показывается вместо всей верстки и не прекращает работу при
        загрузке данных потому что нету изменения в state? исправим это.

        //! Часто в пределах одного компонента его разделяют на условные компоненты - логические и рендерящие
        создадим тут же компонент View который принимает в себя объект char(его деструктуризируем чтобы достать свойства) и 
        возвращает кусок верстки, так сделали потому что она динамическая в отличие от другой верстки. Это простой рендерящий
        коспонент, в нем нет никакой логики, как аргумент получает объект с данными и возвращает участок верстки которую нужно
        просто отобразить. А вся логика и запросы находяться в основном компоненте. Также деструктуризацию char в основном 
        компоненте уже делать не нужно, вытаскиваем его как объект и теперь вместо условия иф делаем условный рендеринг через
        тернарный оператор прямо в верстке, передавая char как props в компонент View

                render() {
                    const {char, loading} = this.state
                    
                    return (
                        <div className="randomchar">
                        { loading ? <Spinner/> : <View char={char} /> }
                            <div className="randomchar__static">
                        ...

            const View = ({char}) => {
                const {name, description, thumbnail, homepage, wiki} = char

                return (
                    <div className="randomchar__block">
                        <img src={thumbnail} alt="Random character" className="randomchar__img"/>
                        <div className="randomchar__info">
                            <p className="randomchar__name">{name}</p>
                            <p className="randomchar__descr">
                                {description}
                            </p>
                            <div className="randomchar__btns">
                                <a href={homepage} className="button button__main">
                                    <div className="inner">homepage</div>
                                </a>
                                <a href={wiki} className="button button__secondary">
                                    <div className="inner">Wiki</div>
                                </a>
                            </div>
                        </div>
                    </div>
                )
            }

        Добавили align-items: center; в ксс файл чтобы спиннер был по центру блока.


        Добавим в метод onCharLoaded кроме внесения в state char еще и изменение свойства loading, и это изменение произойдет только
        когда будет получен ответ от сервера.
            
            onCharLoaded = (char) => {
                this.setState({
                    char,
                    loading: false
                })
            }



    Теперь пофиксим проблему - когда попадаем на id где нету персонажа приложение падает, будем ловить ошибку и показывать другого
        персонажа. Создадим свойство error в state и по умолчанию оно будет false, для обработки ошибки сделаем метод onError, чтобы
        словить ошибку - она возникает после запроса, продолжим цепочку then - catch и если ошибка будет то запустим метод onError.
        В этом методе устанавливаем loading в фолсе, потому что уже не будет загрузки, а error в true. 
            
            state = {
                char: {},
                loading: true,
                error: false
            }

             onError = () => {
                this.setState({
                    loading: false,
                    error: true
                })
            }

        
        Теперь чтобы отобразить ошибку необходим отдельный компонент с сообщением об ошибке который мы сможем переиспользовать в 
        любой части приложения. Создадим отдельную папку и компонент в ней. Этот компонент будет ф-м который возвращает разметку
        img с картинкой (статичным файлом ) которую поместим в папку public. На прямую путь прописать нельзя, не сработает.
        Для того чтобы добраться до папки public нужно использовать переменную окружения  process.env.PUBLIC_URL - и так как это ссылка
        только до папки еще укажем через конкатенацию путь именно к картинке.  process.env.PUBLIC_URL - это переменная которую 
        предоставляет из коробки (реакт или нод)

            const ErrorMessage = () => {
                return (
                    <img src={process.env.PUBLIC_URL + "/error.gif"} />
                )
            }

        //! Но автор даже рекомендует переместить нужный файл в папку в которой лежит компонент который использует этот файл и 
        //! импоритровать прямо в компонент, так мы и сделаем, также добавим инлайн стили чтобы красиво смотрелась.

            import img from "./error.gif"

            const ErrorMessage = () => {
                return (
                    <img src={img} style={{ display: 'block', width: '250px', height: '250px', objectFit: 'contain', 
                                            margin: '0 auto'}} alt="Error" />
                )
            }

            export default ErrorMessage


        RandomChar импортируем компонент ошибки. Теперь нужно показывать какой то компонент в зависимости от состояний, добавлять
        к тернарному выражению еще что то будет некрасиво и путанно, обычно если нужно отображать компонент в зависимости от 
        многих состояний то логику выносят выше return. Вытягиваем erroк из state и создаем для каждого состояния переменную 
        которая или будет хранить компонент или null и потом эти переменные вставляем в верстку, если у переменной значение будет
        null то она не отрендериться, таким образом переменная с компонентом будет всего одна, а остальные будут с null. 

            import ErrorMessage from '../errorMessage/ErrorMessage';

            render() {
                const {char, loading, error} = this.state
                const spinner = loading  ? <Spinner /> : null
                const errorMessage = error ? <ErrorMessage /> : null
                const content = !( loading || error) ? <View char={char} /> : null

                return (
                    <div className="randomchar">
                    { spinner }
                    { errorMessage }
                    { content }

        content переменная будет содержать компонент если НЕ загрузка(loading) или НЕ ошибка(error)

        
*/}

{/*    ====    05. Жизненный цикл компонентов     ====
 
    Жизненный цикл компонентов - life cycle. Сейчас у нас из компонента RandomChar происходит два запроса, потому что вызов
        ф-ии которая отправляет запрос на сервер происходит в конструкторе, до коструирования класса. С сетевыми запросами может
        быть еще несколько багов при таком подходе. 

        //! ПРИМЕР, это повторять не нужно.
        Рассмотрим такой баг как утечка памяти. Допустим что компонент RandomChar должен удаляться и потом заново 
        показываться(создаваться), для этого переделаем App компонент в классовый чтобы у него был локальный стейт в него добавим
        свойство showRandomChar: true, и создадим метод который будет тогглить(переключать на противоположное состояние) это свойство

            toggleRandomChar = () => {
                this.setState((state) => {
                    return {
                        showRandomChar: !state.showRandomChar
                    }
                })
            }


        Повесим этот метод на кнопку и добавим ее ниже компонента RandomChar, а сам компонент будем показывать если showRandomChar
        в позиции true тогда компонент RandomChar будет отображен иначе будет пустота(будет удаляться со страницы).
            
            { this.state.showRandomChar ? < RandomChar /> : null}
            <button onClick={this.toggleRandomChar}>Click Me</button>

            При клике на кнопку каждый раз пересоздается компонент и снова выполняется 2 запроса.


        Теперь представим что нам нужно чтобы этот компонент обновлялся каждые 3 секунды с новым персонажем(тоесть будет посылаться
        запрос на сервер), для этого вместо вызова ф-и updateChar пропишем ее как колбек ф-ю в setInterval, там же в конструкторе.
        Для отслеживания запросов создадим консоль лог в onCharLoaded перед setState. При этом каждый раз выполняется 2 запроса.

        Если нажать на кнопку которая убирает компонент - то он удалится, но запросы продолжают отправляться, если еще раз нажать
        на кнопку - создается новый компонент(екземпляр класса) и он тоже начинает посылать запросы, и с каждым новым созданием 
        компонента он будет начинать посылать запросы при том что запросы от всех удаленных компонентов тоже будут работать, с
        таким поведением приложение может тормозить или вообще зависнуть.

        Это поведение связано с тем что мы не использовали clearInterval чтобы удалить(остановить) интервал, а в JS если есть ссылка
        на какой то объект то он из памяти не исчезает, и получается интервал держит в памяти все удаленные со страницы компоненты
        таким образом создавая утечку памяти.
        
        Чтобы устранить эти два бага нам нужно знать в каком месте написать клир интервал и делать запуск ф-и запросов на сервер,
        для этого рассмотрим жизненный цикл компонента.



    Жизненный цикл:
        - ПОЯВЛЕНИЕ (монтирование - mount) на странице
        - ОБНОВЛЕНИЕ (update) получая 
                new props или 
                new локальный state (setState)
        - УДАЛЕНИЕ (размонтирование - unmount ) со страницы

        4й не основной этап - ОШИБКА


        На каждом из этапов мы можем вызвать ф-и относящиеся к этапу - хуки жизненного цикла (hoocks)
        - Появление - componentDidMount()
        - Обновление - componentDidUpdate()
        - Удаление - componentWillUnmount()
        - Ошибка - componentDidCatch()

        Это не все хуки, но в 95% используются они.


        //! По ссылке https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/ можно видеть жизнынный цикл компонента и
        //! порядок создания компонента. Баг с двумя запросами получался из-за того что запрос происходил из конструктора и ответ
        //! который прийдет еще негде отобразить и возможно даже некуда положить потому что state тоже моголо не быть и поэтому 
        //! после создания компонента React сам посылал второй запрос и обновлял компонент актуальными данными. По этой тамбличке 
        //! видно что делать побочные действия такие как сетевой запрос можно только после рендера тоесть в 3х хуках которые мы
        //! видели выше.

        Таким образом переместим сетевой запрос из конструктора в ф-ю componentDidMount - которая вызывается сразу после создания
        компонента на странице.

            componentDidMount() {
                this.updateChar()
            }

            видим что предупреждение пропалои и запрос происходит 1 раз.


        Чтобы решить проблему с остановкой интервала нужно прописать clearInterval в ф-и componentWillUnmount и теперь при удалении
        компонента таймер тоже будет останавливаться, а компонент полностью удаляться из памяти.

            componentDidMount() {
                this.updateChar()
                this.timerId = setInterval(this.updateChar, 3000)
            }

            componentWillUnmount() {
                clearInterval(this.timerId)
            }

            //! такой баг может быть не только при таком поведении на странице, а при переходе на другие страницы нашего SPA 
            //! приложения, при этом все компоненты текущей страници будут уничтожаться и если на них висят такие запросы по
            //! таймауту то они продолжат работать. Поэтому всегда нужно выполнять отписку от повторяющихся действий.
            
            //! Если в реакте где то назначаем обработчик события через addEventListener то обязательно его потом нужно удалять 
            //! при помощи removeEventListener, если этого не сделать то удаленный элемент не удалиться из памяти и будет занимать
            //! там место.


        Конструктор теперь не нужен можно его удалить.



    //todo 1) По клику на кнопку Try It нужно сделать загрузку нового героя 
    //todo 2) Если картинка не найдена присылается заглушка, но она не ровно стоит, нужно у нее поставить object-fit: contain
    //todo 3) Сделать логику для получения 9ти персонажей и заполнения ими нижних елементов на странице. Не забыть про ключи.
    
    
*/}

{/*    ====    06.  Практика с жизненным циклом, componentDidUpdate     ====
 
    Домашнее задание 1 моя реализация - добавить на кнопку вызов метода updateChar

            <button className="button button__main" onClick={this.updateChar}>
                <div className="inner">try it</div>
            </button>

        но чтобы юзер понимал что было нажатие по кнопке и происходит запрос нужно чтобы он видел спиннер после клика на кнопку.
        Иван реализовал это путем добавления состояния спиннера в state в true в методе updateChar перед выполнением запроса.

            onCharLoading = () => {
                this.setState({
                    loading: true
                })
            }

            updateChar = () => {
                const id = Math.floor(Math.random() * (1011400 - 1011000) + 1011000)
                this.onCharLoading
                this.marvelService
                    .getCharacter(id)
                    .then(this.onCharLoaded)
                    .catch(this.onError)
            }



    Домашнее задание 2 - моя реализация, я посмотрел что при отсутствии картинки приходит картинка с названием всегда одинаковым
        (жаль не увидел что путь к ней тоже всегда одинаковый, тогда бы реализовал как у Ивана) и через проверку строки на нужное
        слово получал булево значение в зависимости от которого показывал нужный тег с инлайн стилем который нужно сменить при
        отсутствующей картинке, а если менять не нужно тогда свойство оставалось стандартное.

             const thumbnailImg = thumbnail.includes('not') 
                        ? <img src={thumbnail} style={{objectFit:"contain"}} alt="Random character" className="randomchar__img"/> 
                        : <img src={thumbnail} alt="Random character" className="randomchar__img"/>

            return (
                <div className="randomchar__block">
                    {thumbnailImg} 


        Реализация Ивана сделана через сравнение строки, так как путь к стандартной заглушке одинаковый он сразу менял свойство
        ксс и просто вставлял его в тег принудительно перезаписывая свойство из ксс файла в обоих случаях

            const imgStyle = {objectFit:"cover"}
            if(thumbnail=== "hhtp://...imgPath") {
                imgStyle = {objectFit:"unset"}
            }

            return (
                <div className="randomchar__block">
                <img src={thumbnail} style={imgStyle} alt="Random character" className="randomchar__img"/> 



    Домашнее задание 3

        Список элементов формируется через map массива с объектами, которые были получены по запросу и при этом тоже мапились с 
        вытаскиванием нужных свойств в каждый объект. Иван сократил код, так как нам не нужно в этом компоненте делать апдейт то
        код из апдейт он перенес сразу в componentDidMount. А вместо компонента View теперь renderItems метод, который мы запускаем
        в рендере перед определением errorMessage spinner content , и передаем в этот методо массив с объектами из state.
        Также в сервисах добавили вытаскивание id из запроса и помещения этого id в каждый компонент чтобы не было ошибок и чтобы
        потом к нему можно было обратиться по наведению мышкой.



    Следующий этап развития приложения - по клику на карточку из списка - выводить информацию про нее справа от списка в компоненте
        CharInfo. Сделаем это так - при клике на карточку в списке будем получаеть ее id и передавать его в CharInfo копонент чтобы 
        он сделал запрос по этому id и получил информацию с сервера. Так как в App CharInfo и CharList находятся на одном уровне то
        для передачи из листа в инфо id нужно использовать поднятие состояния(state), и потом это состояние передавать в инфо как
        props. 
        
        Для того чтобы создать state переделаем App в классовый компонент. Создадим метод для установки нового значения state и 
        передадим его в компонент CharList чтобы там его запускать. А в info будем передавайть id из state
            
            class App extends Component {
                state = {
                    selectedChar: null
                }
                
                onCharSelected = (id) => {
                    this.setState({
                        selectedChar: id
                    })
                }
                
                render() {
                    return (
                        <div className="app">
                            <AppHeader/>
                            <main>
                                <RandomChar/>
                                <div className="char__content">
                                    <CharList onCharSelected={this.onCharSelected}/>
                                    <CharInfo charId={this.state.selectedChar}/>


    
        В CharList добавим вызов этого метода при клике на карточку(проверить можно нажав на App в Component - react developer tools
        в панели разработчика):

            <li 
                className="char__item"
                key={item.id}
                onClick={() => this.props.onCharSelected(item.id)}>



        В CharInfo сделаем и спиннер и обработку ошибки и состояние, так что тоже переделываем в классовый. Он будет идентичен
        RandomChar видим что код повторяется и можно его оптимизировать, пройдем такую оптимизацию в конце следующего модуля (08)
        но не всегда такая оптимизация не всегда нужна, но мы ее рассмотрим позже, сейчас работаем так.

        Создадим метод updateChar для обновления этого компонента при клике на персонажа в CharList. Деструктурируем charId из 
        пришедших props, если в props нету charId (например первый запуск или ошибка), тогда остановим метод прописав return и 
        тогда будет отображаться елемент - skeleton - как заглушка. Если id есть тогда выполняется запрос не сервер. В state
        loading по умолчанию будет false потому что по макету этот компонент не загружается при монтировании, там стоит заглушка
        skeleton.

            updateChar = () => {
                const {charId} = this.props
                if (!charId) {
                    return
                } 

                this.onCharLoading()
                this.marvelService
                    .getCharacter(charId)
                    .then(this.onCharLoaded)
                    .catch(this.onError)
            }


        методы ниже будут повторяться как в RandomChar, потому что логика такая же. 
            
            onCharLoaded = (char) => {
                this.setState({
                    char,
                    loading: false,
                })
            }

            onCharLoading = () => {
                this.setState({
                    loading: true
                })
            }

            onError = () => {
                this.setState({
                    loading: false,
                    error: true
                })
            }


        Для удобства работы с версткой разделим ее на два компонента - один будет отвечать только за интерфейс View, а второй за 
        логику и состояние - стандартный подход. View будет отображать и спиннер и ошибку и он замещает всю верстку, так что
        поместим в него все внутренности верстки кроме родительского тега <div className="char__info">, для этого используем
        реакт фрагмент чтобы не нарушить верстку. 
        
        А во втором компоненте - вытаскиваем все сущности из state для работы спинера, ошибки и обычной загрузки. Импортируем 
        компоненты ошибки, спинера, скелетона. Условия работы похожи на условия из RandomChar но нужно сделать дполнительное
        при начальной загрузке когда показывать скелетон(не загрузка, не ошибка и отсутствует персонаж) - показываем скелетон.
        При этом измениться логика показа персонажа, теперь он будет показан если нету loading или error, но есть персонаж, так
        как в начале прописано ! - не, то для наявности персонажа нужно прописать еще одно ! - не.

            render() {
                const {char, loading, error} = this.state

                const skeleton = char || loading || error ? null : <Skeleton />
                const spinner = loading  ? <Spinner /> : null
                const errorMessage = error ? <ErrorMessage /> : null
                const content = !( loading || error || !char) ? <View char={char} /> : null


                return (
                    <div className="char__info">
                        {skeleton}
                        {spinner}
                        {errorMessage}
                        {content}
                    </div>
                )
            }
            
        Skeleton не показывался потому что в state нужно char присвоить null, а был пустой объект, который превращается в true.
        

        При выборе персонажа из списка скелетон не менятется, так происходит потому что updateChar у нас только в методе
        componentDidMount и он запускается только 1 раз, нужно его вызывать в componentDidUpdate так как этот метод запускается
        в момент обновления компонента от изменения state или новых props, а новые props как раз и приходят.
        //! componentDidUpdate принимает 3 аргумента(3й snapshot очень редко используется, так что пока его не трогаем), остальные
        //! 2 - prevProps и prevState, тоесть когда вызывается этот хук он получает пердыдущее состояние props и предыдущее state,
        //! делается это для того чтобы можно было делать сравнение с предыдущими данными. 

        //! Если сейчас просто поместить в хук апдейте updateChar то будет ошибка максимальной глубины обновления. Тоесть запустится
        //! updateChar в своей цепочке он запускает onCharLoaded который вызывает setState - обновление состояния, которое вызывает
        //! метод render - перерисовку всех компонентов, это значит что компонент обновился и снова вызовется componentDidUpdate
        //! и цепочка снова пойдет по кругу делая постоянную перезагрузку.

        //! Как раз чтобы избавиться от такого поведения нам и нужны предыдущие данные чтобы проверять изменились ли он действительно
        //! и только если изменились тогда запускать выполнение нужной ф-и. В данном случае это позволяет не только не попадать в
        //! бесконечную петлю, но и не делать лишних запросов если юзер будет кликать по одному и тому же персонажу.

            componentDidUpdate(prevProps, prevState) {
                if(this.props.charId !== prevProps.charId){
                    this.updateChar()
                }
            }


        Теперь нужно изменить верству чтобы загружались отображались данные загруженого персонажа, для этого деструктурируем 
        объект char на нужные составляющие.

            const View = ({char}) => {
            const {name, description, thumbnail, homepage, wiki} = char

            return (
                <>
                <div className="char__basics">
                <img src={thumbnail} alt={name} />
                <div>
                    <div className="char__info-name">{name}</div>
                    <div className="char__btns">
                        <a href={homepage} className="button button__main">
                            <div className="inner">homepage</div>
                        </a>
                        <a href={wiki} className="button button__secondary">
                            <div className="inner">Wiki</div>
                        </a>
                    </div>
                </div>
            </div>
            <div className="char__descr">
                {description}
            </div>

        для дальнейшего заполнения верстки не хватает информации о комиксах, если посмотрим на сайте ответ про персонажа -
        можно увидеть там большой объект comics а в нем массив с объектами items (в каждом объекте ссылка и name комикса). 
        Нужно вытащить эти данные в service

            comics: char.comics.items
        
        
        теперь можно вставить эти данные в верстку через map (так как массив), не будем делать отдельный метод для этого, потому
        что компонент простой, сделаем перебор в верстке View. Предварительно вытащив comics из объекта char. В ключ подставим номер
        по порядку в массиве, так допустимо потому что этот список у нас не будет динамически изменяться и путаницы не получится.

            <ul className="char__comics-list">
                {
                    comics.map((item, i) => {
                        return <li key={i} className="char__comics-item">
                                    {item.name}
                                </li>
                    })
                }
            </ul>

        все работает.




    Теперь нужно исправить 3 небольших момента, сначала попробовать исправить их самостоятельно:
        1) в макете комиксы ограничены 10 позициями, нужно так и сделать.
        2) есть персонажи у которых нету комиксов(капитан Флинт) тогда карточка просто обрезается и не понятно толи нету данных
            толи они не загрузились, сделать надпись - the character is not present in the comics
        3) картинка заглушка в CharInfo уезжает - надо отцентрировать

        
        1) мое решение
        
            const comicsList = comics.slice(0, 10)
                
                ...
                {   
                    comicsList.map((item, i) => {


        можно решить кучей способов: 
        можно решить добавив проверку условия прямо в цикл, если номер айтема больше 9ти то запускается return который будет 
        прекращать дальнейшее выполнение , но цикл map все равно будет работать и каждый раз будет делать проверку, если елементов
        будет очень много то пострадает производительность. Если елементов будет много то нужно переписать на обычный цикл с его
        командой break для остановки цикла и сделать так чтобы получать новый массив, не мутируя основной comics.

            comicsList.map((item, i) => {
                if(i > 9) return
                return <li key={i} className="char__comics-item">
                            {item.name}
                        </li>

        //! в консоли eslint ругается на эту строку - используйте с опаской если точно знаете что это не повредит вашему приложению
        //! и предлагает вставить строку //eslint-disable-next-line - перед строкой на которую он ругается, тогда предупреждение
        //! в консоли пропадет.


                
        2) мое решение

            const noComics = comics.length == 0 ? <li>This character is not present in the comics</li> : null
                
                ...
                <ul className="char__comics-list">
                    {noComics}
                    {
                        comicsList.map((item, i) => {

            
        Иван решил практически также, вставив условие прямо в верстку

            <ul className="char__comics-list">
                {comics.length > 0 ? null : "There is no comics with this character"}
                {noComics}
                {
                    comicsList.map((item, i) => {



        3) Взял решение у Ивана из предыдущего кейса, он решил также

            let imgStyle = {'objectFit' : 'cover'};
            if (thumbnail === 'http://i.annihil.us/u/prod/marvel/i/mg/b/40/image_not_available.jpg') {
                imgStyle = {'objectFit' : 'unset'};
            }

                ...
                <img src={thumbnail} style={imgStyle} alt={name} />


*/}

{/*    ====    07. Предохранители (Error Boundaries)     ====

    Рассмотрим последний из частоиспользуемых хуков и познакомимся с приемом - предохранитель.

    В CharInfo в метод updateChar специально внесем ошибку, например обратимся к несуществующему методу  

            this.foo.bar = 0

        при нажатии на персонажа из списка крашиться приложение и выводиться ошибка прямо в окне браузера, а не только в консоли.

        Пишеться какая ошибка и где она произошла(в каком файле и строке). А что будет при работающем приложении? Такое сообщение
        мы получаем только в режиме разработки потому, а в развернутом(выгруженном на сервер) проекте реакт остановит свою работу
        и удалит весь интерфейс оставив пустую страницу.

        Если использовать хук componentDidCath, то сломается только тот компонент который вызвал ошибку, а остальной интерфейс
        останется.
        

        Добавим его в код. componentDidCath принимает 2 аргумента - ошибку и информацию о компоненте в котором произошла ошибка.
        выведем в консоль эту информацию чтобы посмотреть что нам напишет и  установим свойство state - error в true.

            componentDidCatch(err, info) {
                console.log(err, info)
                this.setState({ error: true })
            }

            //! снова появляется оверлей ошибки от реакта но нашего сообщения в консоли нету, так происходит потому что начиная с
            //! 16й версии реакта поведение этого хука было изменено. До 16й версии было так что крашился только тот компонент в
            //! котором происходила ошибка, а остальной интерфейс работал. Но теперь всё равно крашиться все приложение, так было 
            //! задумано чтобы не было багов в интерфейсе, особенно страшно это было в системе платежей, чатах, админках. когда юзер
            //! мог отправить не те данные не в соответствующий участок интерфейса, потому что другой участок сломался и отвалился.

        //! раньше существовал рукотворный прием - предохранитель(error boundary), и разработчики реакта тоже пришли к выводу 
        //! что лучше использовать такие предохранители(спец компоненты), для того чтобы правильно перехватывать такие ошибки.

        //! раньше такой прием был не обязателен, а теперь обязателен. Предохранитель - это обязательно только классовые компоненты
        //! которые оборачивают другие компоненты и если в их дочерних компонентах происходит ошибка, то они будут ее ловить,
        //! при этом приложение не падает, а ломается только этот компонент. И реакт разработчики добавили дополнительные ф-л
        //! что мы можем отрендерить какой то запасной интерфейс вместо сломавшегося и можем записать(залогить) ошибку.

        //! Предохранителей не в классовом виде на момент записи урока не было.


        Создадим предохранитель отдельным компонентом чтобы его переиспользовать. В папке  components делаем папку errorBoundary c 
        файлом ErrorBoundary.js 

        создаем классовый компонент ErrorBoundary в котороб будет state с булевым значением, и если сработает componentDidCatch 
        тогда оно измениться на true и покажет дефолтную страницу(заглушку) - h2 тег, а если ошибки не будет тогда покажется 
        компонент который пришел по пропсам. 

            import {Component} from "react"

            class ErrorBoundary extends Сomponent {
                state = {
                    error: false
                }

                componentDidCatch(error, errorInfo) {
                    console.log(error, errorInfo)
                    this.setState({ error: true })
                }

                render() {
                    if(this.state.error){
                        return <h2>Something went wrong</h2>
                    }

                    return this.props.children
                }
            }

            export default ErrorBoundary

            //! конструкцию children рассмотрим в следующих уроках.



        Импортируем его в App.js и помещаем CharInfo в ErrorBoundary.

            <main>
            <RandomChar />
            <div className="char__content">
                <CharList onCharSelected={this.onCharSelected} />
                <ErrorBoundary>
                    <CharInfo charId={this.state.selectedChar} />
                </ErrorBoundary>
            </div>

            теперь у автора появляется оверлей но когда его закрываем то страница работает а сбоку где должен быть CharInfo 
            выводится сообщение, у меня нету оверлея и страница перестает реагировать, но сообщение вместо CharInfo при ошибке
            тоже показывается.

        Импортируем в ErrorBoundary компонент с ошибкой и будем показывать его вместо текста об ошибке.


        В консоли смотрим на ошибку - первый аргумент название ошибки и где она произошла

            TypeError: Cannot set properties of undefined (setting 'bar')
            at CharInfo.updateChar (CharInfo.js:42:1)

        а  внизу нее есть объект, в котором есть информация в каком компоненте произошла ошибка и эту информацию можно записать
        или отправить на сервер для логирования

            at dispatchDiscreteEvent (react-dom.development.js:5889:1) 



    //! Теперь можно остальные компоненты которые работают с сетью поместить в ErrorBoundary, но тогда возникает вопрост зачем мы
        //! отдельно прописывали логику отлова ошибок в компонентах. Потому что предохранители не могут словить все ошибки, они
        //! ловят только ошибки при запуске метода рендер, в методах жизненного цикла и в конструкторах дочерних компонентов.
        //! Не ловят они ошибки - 1) которые произошли внутри обработчиков событий(потому что они происходят вне метода рендер, 
        //! например если навешан onClick даже верстке/рендере он не выполняется при запуске метода рендар, а ждет пока юзер сделает
        //! клик, поэтому предохранитель не знает когда его отслеживать), 2) асихронный код - по тойже причине, и сетевые запросы
        //! относятся к этому виду, поэтому для них есть специальный метод для отлова ошибок, 3) не ловяться ошибки в самом 
        //! предохранителе(он ловит ошибки только в дочерних компонентах но не внутри себя), 4) серверный рендерниг.



    //! Существует еще один метод getDerivedStateFromError() он тоже используется в предохранителях на равне с componentDidCatch, но
        его суть в том что он только обновляет state. Рассмотрим его на примере, в ErrorBoundary пропишем getDerivedStateFromError()
        через static 

            static getDerivedStateFromError(error){
                return {error: true}
            }

            по факту это такой setState который работает только с ошибкой, дополнительных ф-й в нем быть не должно. Если нужно 
            еще что-то, то нужно использовать componentDidCatch.



    Обернем еще два компонента в App в ErrorBoundary и подумаем как часто использовать этот компонент и оборачивать ли всё подряд.
        Степень охвата кода на свое усмотрение, если предполагаем что компонент может сломаться, тогда его лучше обернуть в
        предохранитель, но сильно усердствовать не нужно, потому что каждый простой маленький компоент оборачивать также не стоит.
        В нашем приложении стоит обернуть RandomChar и  CharList - потому что они работает с сетевыми запросами и что то может 
        пойти не по плану, хотя даже если компонент работает с сетью и если он сломается то ничего критического не произойдет как в 
        RandomChar то можно не оборачивать, достаточно будет ErrorMessage который мы реализовали.


*/}

{/*    ====    08. Пагинация данных (дозагрузка персонажей)     ====
 
*/}

{/*    ====    09. Проверка типов с помощью PropTypes     ====
 
*/}

{/*    ====    10. Вставка элементов через props.children     ====
 
*/}

{/*    ====    11. Специализация и наследование     ====
 
*/}

{/*    ====    12. Render-props паттерн     ====
 
*/}

{/*    ====    13. Что такое ref и зачем он нужен     ====
 
*/}

{/*    ====    14. Порталы     ====
 
*/}

{/*    ====    15. “Бандлинг” и выгрузка проекта на сервер     ====
 
*/}